# ■ 04-1 ALU와 제어장치
## □ ALU Arithmetic and Logical Unit 산술 논리 장치
**레지스터**를 통해 *피연산자를 받아들이고 제어 신호(제어장치로부터 수행할 연산을 알려줌)를 받아들임.*
CPU가 메모리에 접근하는 속도는 레지스터에 접근하는 속도보다 느림.
ALU가 연산할 때마다 결과를 메모리에 저장한다면 CPU는 메모리에 자주 접근하게되고, CPU가 프로그램 실행속도를 지연시킴. -> `ALU의 결과값을 메모리가 아닌 레지스터에 우선 저장`


ALU는 계산결과와 플래그를 반환
▸ **플래그 flag** : 계산 결과에 대한 추가적인 상태 정보
▸ **오버플로우(overflow)** : 연산 결과가 연산결과를 담을 레지스터보다 큰 상황

| 플래그 종류    | 의미                                                               | 사용 예시                                                           |
| --------- | ---------------------------------------------------------------- | --------------------------------------------------------------- |
| 부호 플래그    | 연산한 결과의 부호를 나타낸다.                                                | 부호 플래그가 1일 경우 계산 결과는 음수, 0일 경우 계 산 결과는 양수를 의미한다.                |
| 제로 플래그    | 연산 결과가 0인지 여부를 나타낸다.                                             | 제로 플래그가 1일 경우 연산 결과는 0, 0일 경우 연산 결과는 0이 아님을 의미한다.               |
| 캐리 플래그    | 연산 결과 올림수나 빌림수가 발생했는 지를 나타낸다.                                    | 캐리 플래그가 1일 경우 올림수나 빌림수가 발생했음을 의미하고, 0일 경우 발생하지 않았음을 의미한다.       |
| 오버플로우 플래그 | 오버플로우가 발생했는지를 나타낸다.                                              | 오버플로우 플래그가 1일 경우 오버플로우가 발생했음을 의미하고, 0일 경우 발생하지 않았음을 의미한다.       |
| 인터럽트 플래그  | 인터럽트가 가능한지를 나타낸다. 인터 럽트는 04-3절에서 설명한다.                           | 인터럽트 플래그가 1일 경우 인터럽트가 가능함을 의미 하고, 0일 경우 인터럽트가 불가능함을 의미한다.       |
| 슈퍼바이저 플래그 | 커널 모드로 실행 중인지, 사용자 모드로 실행 중인지를 나타낸다. 커널 모드와 사 용자 모드는 09장에서 설명한다. | 슈퍼바이저 플래그가 1일 경우 커널 모드로 실행 중임을 의미하고. 0일 경우 사용자 모드로 실행 중임을 의미한다. |
플래그들은 **플래그 레지스터**라는 레지스터에 저장.
연산 결과에 대한 추가적인 정보, 참고 정보를 얻을 수 있음.
## □ 제어장치
제어신호를 내보내고 명령어를 해석하는 부품
제어 신호 : 컴퓨터 부품들을 관리하고 작동시키기위한 일종의 전기 신호
CPU 제조사마다 제어장치의 구현방식이나 명령어를 해석하는 방식, 받아들이고 내보내는 정보에 차이가 있음.


1. 제어장치는 **클럭 신호를 받아들임** (컴퓨터 부품이 클럭이라는 박자에 맞춰 작동함 ⤏ 한박자마다 작동이 아님)
   `클럭은 컴퓨터에서 연산을 조장하는 타이밍 신호. cpu가 명령어를 얼마나 빠르게 처리 하는지 결정.`
	1. cpu가 수많은 작업을 할 때 일련의 단계를 거치며 각 단계는 “클럭 사이클” 이라는 특정 시간 간격 동안 수행
	2. 클럭 사이클은 클럭 신호로 제어되며, 이 신호는 일정 주기로 반복되는 펄스 또는 사인파(sine wave) 신호
	3. 신호가 반복되는 속도를 “클럭 속도”라고 하며, 이 속도 단위는 헤르츠(Hz)표시 됨.(헤르쯔(Hz) : 1초 동안 발생하는 신호의 수. 만약에 1 Hz이면 1초동안 1번의 신호가 발생)
2. 제어장치는 **“해석해야 할 명령어"를 받아들임** 
   `해석할 명령어를 받아들이고 해석한 뒤, 제어신호를 발생시켜 컴퓨터 부품에 수행해야 할 내용을 전달`
3. 제어장치는 **플래그 레지스터 속 플래그 값을 받아들임**
   `플래그는 ALU 연산에 대한 추가적인 상태 정보임. 제어장치가 제어 신호를 통해 컴퓨터 부품들을 제어할 시 중요한 정보`
4. 제어장치는 **시스템 버스(제어버스)로 전달된 제어 신호를 받아들임** 
   `제어 버스를 통해 외부로부터 전달된 제어 신호를 받아들이기로함`

제어장치가 메모리에 저장된 값을 읽거나 메모리에 새로운 값을 쓰고 싶다면 메모리로 제어신호를 보냄.
입출력장치의 값을 읽거나 입출력 장치에 새로운 값을 쓰고 싶을 때는 입출력 장치로 제어 신호를 내보냄
ALU에 전달하는 제어 신호와 레지스터에 전달하는 제어신호가 따로 있음.

# ■ 04-2 레지스터
프로그램 속 명령어와 데이터는 실행 전후로 반드시 레지스터에 저장. -> `레지스터에 저장된 값만 잘 관찰해도 프로그램의 실행 흐름을 파악 가능`
## □ 반드시 알아야 할 레지스터
1. *프로그램 카운터 PC Program Counter* (명령어 포인터 Instruction Pointer) 
   메모리에서 가져올 명령어의 주소, 즉 메모리에서 읽어들일 명령어의 주소를 저장
2. *명령어 레지스터 IR Instruction Register*
   해석할 명령어, 즉 방금 메모리에서 읽어들인 명령어를 저장하는 레지스터. 명령어 레지스터 속 명령어를 받아들이고 이를 해석한 뒤 제를어신호 내보냄.
3. *메모리 주소 레지스터 MAR Memory Address Register* 
   메모리 주소를 저장하는 레지스터. CPU가 읽어들이고자 하는 주소값을 버스로 보낼 때 메모리 주소 레지스터를 거치게 됨.
4. *메모리 버퍼 레지스터 MBR Memory Buffer Register*
   메모리와 주고받을 값(데이터와 명령어)을 저장하는 레지스터. 즉, 메모리에 쓰고 싶은 값이나 메모리로부터 전달받은 값은 메모리 버퍼 레지스터를 거침.
5. *플래그 레지스터 Flag Register*
   연산 결과 또는 CPU 상태에 대한 부가적인 정보를 저장.
6. *범용 레지스터 General Purpose Register*
   일반적인 상황에서 자유롭게 사용할 수 있는 레지스터. 데이터와 주소를 모두 저장 가능.
7. *스택 포인터* : 스택(메모리에 있음 
   스택처럼 사용할 수 있는 공간이 미리 지정되어 있음.)의 꼭대기를 가리키는 레지스터 (스택이 어디까지 차 있는지에 대한 표시)
8. *베이스 레지스터* : 변위주소지정방식에서 사용하는 레지스터

  
```ad-question 
순차적인 실행 흐름이 끊기는 경우?
→ 프로그램 카운터는 꾸준히 증가하여 프로그램을 차례대로 실행. 
```

```ad-question
전혀 다른 값으로 업데이트 되는 경우?
→ 특정 메모리 주소로 실행 흐름을 이동하는 명령어(Jump .. 등)가 실행되었을 때 차례대로 실행되지 않음.
→ 인터럽트가 발생해도 프로그램의 순차적인 실행이 끊김.
```
## □ 특정 레지스터를 이용한 주소 지정방식(1): 스택 주소 지정 방식

```ad-info
스택이 어디있나?
→ 스택은 메모리에 있음. 
메모리 안에 스택처럼 사용할 영역이 스택영역이다. 
주소 공간과는 다르게 스택처럼 사용하기로 암묵적으로 **약속된** 영역.
```
#### **스택 포인터 stack pointer**
스택 주소 지정 방식이라는 주소 지정 방식에 사용되고, 프로그램 카운터와 베이스 레지스터는 변위 주소 지정 방식이라는 주소 지정 방식에 사용되고, 프로그램 카운터와 베이스 레지스터는 변위 주소 지정 방식이라는 주소 지정 방식에 사용됨.

▸ 스택 주소 지정 방식 : 스택과 스택포인터(스택의 마지막으로 저장한 값의 위치를 저장하는 레지스터)를 이용한 주소 지정 방식.

## □ 특정 레지스터를 이용한 주소 지정 방식(2): 변위 주소 지정 방식
▸ 변위 주소 지정 방식 Displacement addressing mode
```ad-important
- 프로그램 카운터
- 베이스 레지스터
```

1. 상대 주소 지정 방식 : 오퍼랜드 필드의 값(변위)과 프로그램 카운터의 값을 더하여 유효 주소를 얻어내는 주소 지정 방식.
2. 베이스 레지스터 주소 지정 방식 : 오퍼랜드 필드의 값(변위)과 베이스 레지스터의 값을 더하여 유효 주소를 얻어내는 주소 지정 방식.

▸ *상대 주소 지정 방식 Relative Addressing Mode* 
오퍼랜드와 프로그램 카운터의 값을 더하여 유효 주소를 얻는 방식.

▸ *베이스 레지스터 주소 지정 방식 Base-Register Addressing Mode*

오퍼랜드와 베이스 레지스터의 값을 더하여 유효 주소를 얻는 방식. 베이스레지스터는 ‘기준 주소', 오퍼랜드는 ‘기준 주소로부터 떨어진 거리'로서의 역할을 함. 베이스 레지스터 주소 지정 방식은 베이스 레지스터 속 기준 주소로부터 얼마나 떨어져있는 주소에 접근할 것인지를 연산하여 유효 주소를 얻어내는 방식.

# ■ 04-3 명령어 사이클과 인터럽트
## □ 명령어 사이클
#### 명령어 사이클
CPU는 명령어들을 하나씩 실행하는데 프로그램 속 각각의 명령어들을 일정한 주기를 반복하며 실행.
#### 인출 사이클 Fetch cycle
메모리에 있는 명령어를 CPU로 가지고 오는 단계.
#### 실행 사이클 Execution cycle
CPU로 가져온 명령어를 실행하는 단계. 제어장치가 명령어 레지스터에 담긴 값을 해석하고, 제어 신호를 발생시키는 단계.

간접 주소 지정 방식은 오퍼랜드 필드에 유효 주소의 주소를 명시. 명령어를 인출하여 CPU로 가져왔다 하더라도 바로 실행 사이클에 돌입할 수 없음. 명령어를 실행하기 위해서는 메모리 접근을 한 번 더 해야하기 때문.

  

## □ 인터럽트
인터럽트 Interrupt : *CPU의 작업을 방해하는 신호*
#### 동기 인터럽트 Synchronous interrupt (예외)
CPU에 의해 발생하는 인터럽트
#### 비동기 인터럽트 Asynchronous interrupt (하드웨어 인터럽트)
입출력장치에 의해 발생하는 인터럽트
	▸ 하드웨어 인터럽트
	알림과 비슷. 하드웨어 인터럽트를 이용 → CPU는 프린트로부터 프린트 완료 인터럽트를 받을 때까지 다른 작업을 처리할 수 있음.

  

#### 하드웨어 인터럽트 처리 순서
1. 입출력장치는 CPU에 인터럽트 요청 신호를 보냄
2. CPU는 실행사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부를 확인
3. CPU는 인터럽트 요청을 확인하고 인터럽트 플래그를 통해 현재 인터럽트를 받아들일 수 있는지 여부 확인
4. 인터럽트를 받아들일 수 있다면 CPU는 지금까지의 작업을 백업
5. CPU는 인터럽트 벡터를 참조하여 인터럽트 서비스 루틴을 실행
6. 인터럽트 서비스 루틴 실행이 끝나면 (4)에서 백업해 둔 작업을 복구하여 실행을 재개

#### 인터럽트 플래그 interrupt flag
CPU가 인터럽트 요청을 수용하기 위해서는 플래그 레지스터의 인터럽트 플래그가 활성화 되어 있어야 함. 
```ad-note
*인터럽트 플래그*
하드웨어를 받아들일지 무시할지 결정하는 플래그.
```

CPU가 인터럽트 요청을 받아들이기로 했다면 CPU는 인터럽트 서비스 루틴이라는 프로그램을 실행. 인터럽트 서비스 루틴 ISR Interrupt Service Routine(Interrupt Handler)은 인터럽트를 처리하기 위한 프로그램임.

#### 인터럽트 서비스 루틴
어떤 인터럽트가 발생했을 때 해당 인터럽트를 어떻게 처리하고 작동해야할지에 대한 정보로 이루어진 프로그램.
CPU가 인터럽트를 처리함 → 인터럽트 서비스 루틴을 실행하고 본래 수행하던 작업으로 다시 돌아온다.
*인터럽트 벡터 Interrupt vector* : CPU가 인터럽트 서비스 루틴을 식별하기 위한 정보. 

#### 예외
예외가 발생하면 CPU는 하던 일을 중단하고 예외를 처리
1. 폴트 : 예외를 처리한 직후 예외가 발생한 명령어부터 실행을 재개.
2. 트랩 : 예외를 처리한 직후 예외가 발생한 명령어의 다음 명령어 부터 실행을 재개.
3. 중단 : CPU가 실행중인 프로그램을 강제로 중단 시킬수 밖에없는 심각한 오류를 발견했을 때 .
4. 소프트웨어 인터럽트 : 시스템 호출이 발생 했을 때.




