# ■ 11-1 CPU 스케줄링 개요

▸ CPU 스케줄링 (CPU scheduling) : 운영체제가 프로세스들에게 공정하고 합리적으로 CPU자원을 배분하는 것. 컴퓨터 성능과 직결

## □ 프로세스 우선순위

▸ 우선순위가 높은 프로세스 : 빨리 처리해야하는 프로세스 

ex. 입출력작업이 많은 프로세스

▸ 입출력 집중 프로세스 (I/O bound process) : 비디오 재생, 디스크백업작업 등의 입출력이 많음. (대기상태에 더 많이 머무름) ⇢ I/O burst

▸ CPU 집중 프로세스 (CPU bound process) : 복잡한 수학연산, 컴파일, 그래픽 처리작업 등 CPU 작업이 많음. (실행상태에 더 많이 머무름) ⇢ CPU burst

위 프로세스의 중요도나 각각의 상황에 맞게 프로세스가 CPU를 이용할 수 있도록 PCB에 우선순위를 부여함

  

*참고*

프로세스 우선순위 직접확인하기 위해서는 unix계열에서는 ps -el명령어를 통해 확인가능 / nice로 우선순위 변경가능.


리눅스는 CFS(Completely Fair Scheduling) 스케줄링 알고리즘 사용.

priority(우선순위)는 nice값에 의해 정해진다. (pri를 사용자가 직접 설정할 수는 없지만 nice값을 조정하여 pri를 설정할 수있음,  -20 ~ 20사이로 설정가능하며, root이외의 사용자는 negative한 값을 설정할수없다;일반사용자의 cpu독점을 막기위해 ⇢ 음수일 수록 우선순위가 높음!)

□ 스케줄링큐

PCB에 우선순위가 명시되어있지만 CPU를 사용할 다음 프로세스를 찾기 위해 운영체제가 일일이 모든 프로세스의 PCB를 뒤적거리는 것은 비효율적임. ⇢ 줄세우기! 스케줄링 큐(scheduling queue)를 활용

*queue는 자료구조관점에서 선입선출이지만 스케줄링에서의 큐는 반드시 선입선출은 아님.

*운영체제가 관리하는 대표적인 queue

  ⑴ 준비 큐 (ready queue) : CPU를 이용하고싶은 프로세스들이 서는 줄.

  ⑵ 대기 큐 (waiting queue) : 입출력장치를 이용하기 위해 대기상태에 접어든 프로세스들이 서는 줄.

□ 선점형과 비선점형 스케줄링

▸ 선점형 스케줄링 (preemptive scheduling) : 프로세스가 CPU를 비롯한 자원을 사용하고 있더라도 운영체제가 프로세스로부터 자원을 강제로 빼앗아 다른 프로세스에 할당할 수 있는 스케줄링 방식.

장 : 어느 한 프로세스의 자원독점을 방지하여 프로세스들에 골고루 자원배분이 가능

단 : 문맥교환 과정에서 오버헤드 발생가능성

▸ 비선점형 스케줄링 (non-preemptive scheduling) : 하나의 프로세스가 자원을 사용하고 있다면, 그 프로세스가 종료되거나 스스로 대기상태에 접어들기전까진 다른 프로세스가 끼어 들수 없는 스케줄링 방식. 비선점형 스케줄링 방식으로 자원을 접근하는 프로세스가 있으면 다른 프로세스들은 그 프로세스의 사용이 끝날때까지 대기해야 함.

장 : 문맥교환의 횟수가 선점형스케줄링보다 적기때문에 오버헤드 가능성 적음. 

단 : 하나의 프로세스가 자원사용 시 다른 우선순위가 높은 프로세스가 들어와도 대기해야함.

# ■ 11-2 CPU 스케줄링 알고리즘

□ 스케줄링 알고리즘의 종류

  ⑴ 선입 선처리 스케줄링 (FCFS scheduling; first come first served scheduling)

  ⑵ 최단 작업 우선 스케줄링 (SJF scheduling; shortest job first scheduling)

  ⑶ 라운드 로빈 스케줄링 (round robin scheduling)

  ⑷ 최소 잔여 시간 우선 스케줄링 (SRT scheduling; shortest remaining time)

  ⑸ 우선순위 스케줄링 (priority scheduling)

  ⑹ 다단계 큐 스케줄링 (multilevel queue scheduling)

  ⑺ 다단계 피드백 큐 스케줄링 (multilevel feedback queue scheduling)

  

▸ 선입 선처리 스케줄링 (FCFS scheduling; first come first served scheduling)

: 준비 큐에 삽입된 순서대로 프로세스들을 처리.

가장 공정해보이지만 프로세스들이 기다리는 시간이 매우 길어질 수 있음.

*호위효과(convoy effect : 짧은 실행을 위하여 긴 시간을 대기) 발생가능성.

  

▸ 최단 작업 우선 스케줄링 (SJF scheduling; shortest job first scheduling)

: 호위효과 방지위해 준비 큐에 삽입된 프로세스 들 중 cpu 이용시간의 길이가 가장 짧은 프로세스부터 실행.

➽ 비선점뿐 아니라 선점 가능!

  

▸ 라운드 로빈 스케줄링 (round robin scheduling)

: 선입선처리 스케줄링에 타임 슬라이스라는 개념이 더해진 스케줄링 방식. ⇢ 정해진 타임슬라이스 만큼의 시간동안 돌아가며 CPU를 이용하는 선점형 스케줄링.

*타임슬라이스 : 각 프로세스가 CPU를 사용할 수 있는 정해진 시간을 의미. 타임슬라이스의 크기가 중요함.

너무 크면 선입선처리와 다를바없고, 너무 작으면 문맥교환으로 인한 오버헤드가 발생함.

  

▸ 최소 잔여 시간 우선 스케줄링 (SRT scheduling; shortest remaining time)

: 최단작업 우선 스케줄링의 선점형 스케줄링 방법. 최단작업 우선스케줄링 알고리즘과 라운드로빈 알고리즘을 합친 스케줄링 방식. 최소 잔여 시간 우선 스케줄링하에서 프로세스들은 정해진 타임 슬라이스만큼 CPU를 사용하되, CPU를 사용할 다음 프로세스로는 남아있는 작업시간이 가장 적은 프로세스가 선택됨.

  

▸ 우선순위 스케줄링 (priority scheduling)

: 프로세스들에 우선순위를 부여하고 가장 높은 우선순위를 가진 프로세스부터 실행.

*기아(starvation) 현상 발생가능 ⇢ 우선순위가 높은 프로세스만 계속 먼저 실행되어 우선순위가 낮은 작업들은 계속 뒤로 밀림.

*에이징 (aging): 기아현상을 방지하기 위한 기법으로, 오랫동안 대기한 프로세스의 우선순위를 점차 높이는 방식.

  

▸ 다단계 큐 스케줄링 (multilevel queue scheduling)

: 우선순위 스케줄링의 발전된 형태. 우선순위별로 준비 큐를 여러개 사용하는 스케줄링 방식. 다단계 큐 스케줄링 하에서는 우선순위가 가장 높은 큐에 있는 프로세스들을 먼저 처리하고 우선순위가 가장 높은 큐가 비어있으면 그 다음 우선순위 큐에있는 프로세스들을 처리.

큐를 여러개두면 프로세스 유형별로 우선순위를 구분하여 실행하는 것이 편리해 지며, 큐마다 다른 스케줄링 알고리즘을 사용할 수 있음.

  

▸ 다단계 피드백 큐 스케줄링 (multilevel feedback queue scheduling)

: 다단계 큐 스케줄링의 발전된 형태, 다단계 큐 스케줄링과는 달리 프로세스들이 큐 사이를 이동할 수가 있음. (기아현상 발생 가능성⇣). 어떤 프로세스의 CPU 이용시간이 길면 낮은 우선순위 큐로 이동시키고 어떤 프로세스가 낮은 우선순위 큐에서 너무 오래 기다린다면 높은 우선순위 큐로 이동시키는 알고리즘.

① 새로 준비상태가 된 프로세스가 있으면 우선순위가 가장 높은 우선순위 큐에 삽입되고 일정시간동안 (타임슬라이스) 실행

② 프로세스가 해당 큐에서 실행이 끝나지 않는다면 다음 우선순위 큐에 삽입되어 실행

③ 타임 슬라이스 동안 실행을 다 못끝내는 경우 우선순위 하락시킴

④ CPU를 비교적 적게 사용하는 프로세스들은 자연스레 우선순위가 높은 큐에서 실행이 끝남

⑤ 프로세스들이 큐 사이를 이동할 수 있는 방식이기때문에 낮은 우선순위 큐에서 너무 오래 기다리고있는 프로세스가 있다면 점차 우선순위가 높은 큐로 이동시키는 에이징 기법을 적용해 기아현상을 예방
