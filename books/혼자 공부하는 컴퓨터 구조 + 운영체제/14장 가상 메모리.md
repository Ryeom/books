# ■ 14-1 연속 메모리 할당
▸ 연속 메모리 할당 : 프로세스에 연속적인 메모리 공간을 할당하는 방식.
## □ 스와핑(swapping) 
현재 실행되지 않는 프로세스(오랫동안 사용 되지 않은 프로세스)를 임시로 보조기억장치 일부 영역으로 쫓아내어 생긴 메모리 상의 빈 공간에 또 다른 프로세스를 적재하여 실행하는 메모리 관리 기법.

▸ **스왑 영역(swap space)** : 프로세스들이 쫓겨나는 보조기억장치의 일부 영역. 

▸ *스왑 아웃(swap-out)* : 현재 실행되지 않는 프로세스가 메모리에서 스왑 영역으로 옮겨지는 것.
▸ *스왑 인(swap-in)* : 반대로 스왑영역에 있던 프로세스가 다시 메모리를 다시 메모리로 옮겨오는 것.

```ad-advantage
프로세스들이 요구하는 메모리 주소공간의 크기가 실제 메모리 크기보다 큰 경우에도 프로세스들을 동시 실행 가능.
```

```ad-tip
unix계열에서는 free, top 등을 통해 스왑영역의 크기 확인 가능.(스왑 크기는 사용자 설정 가능)
```

※ 프로세스들이 요구하는 메모리 공간 크기 > 실제 메모리 크기
 
## □ 메모리 할당
*메모리 내에 빈 공간이 여러 개 있을 경우 프로세스를 배치하는 방법*
1. **최초적합** : 운영체제가 메모리 내의 빈 공간을 순서대로 검색하다가 적재 할 수 있는 공간을 발견하는 즉시 배치(빠름) ⇢ 빈공간A
2. **최적적합** : 빈공간을 모두 검색한 뒤 가능한 가장 작은 공간에 배치 ⇢ 빈공간C
3. **최악적합** : 빈공간을 모두 검색한 뒤 가능한 가장 넓은 공간에 배치 ⇢ 빈공간B
 

## □ 외부 단편화(external fragmentation)
프로세스를 할당하기 어려울 만큼 작은 메모리 공간으로 인해 메모리가 낭비되는 현상.

연속 메모리 할당은 외부 단편화 때문에 효율적인 방법이 아님!

프로세스들이 메모리에 연속적으로 할당되는 환경에서, 실행과 종료를 반복하며 메모리들 사이에 빈공간이 할당됨. ⇢ 그 공간 보다 큰 프로세스를 적재하기 어려워 메모리 낭비를 초래.
 

  ```ad-question
  ▸ **외부 단편화** 해결 방법 
1. 메모리 압축(compaction ; 메모리 조각 모음) 
   흩어져 있는 빈 공간을 하나로 모으기 
   but. 하는동안 시스템 중지 및 메모리 데이터 이동은 오버헤드를 야기, 효율적인 압축 방법 없음
   `ex. windows 디스크 조각모음(?)`
2. **페이징 기법(paging)**

```
  

# ■ 14-2 페이징을 통한 가상 메모리 관리
▸ 가상메모리 : 실행하고자 하는 프로그램의 일부만 메모리에 적재하여 실제 물리 메모리 크기보다 더 큰 프로세스를 실행할 수 있게 하는 기술. 

1. *페이징(paging)*
   프로세스를 물리적으로 일정한 크기로 나눠서 메모리에 할당.
2. *세그멘테이션(segmentation)*
   프로세스를 논리적 내용을 기반으로 나눠서 메모리에 배치. 프로세스를 code영역, data영역, stack영역 등으로 나누는 것 또한 세그멘테이션의 일종!
```ad-check
페이징을 더 많이 쓴다 
→ 세그멘테이션의 *세그먼트 크기가 일정하지 않고 다양*하기 때문. 세그먼트의 크기가 다양하기 때문에 다양한 hole이 발생해 외부단편화가 발생하여 메모리 낭비가 큼.
```

  

## □ 페이징
메모리의 **물리 주소 공간을 일정한 프레임(frame) 단위**로 자르고, 프로세스의 *논리 주소 공간을 페이지(page) 단위로 자른 뒤 각 페이지를 프레임에 할당*하는 가상 메모리 관리 기법.

메모리와 프로세스를 일정한 단위로 자르고, 메모리에 불연속적으로 할당!
```ad-note
외부 단편화의 원인
→ 각기 다른 크기의 프로세스가 메모리에 연속적으로 할당되었기 때문!
→ 하나의 프로세스를 실행하기 위해 프로세스 전체가 메모리에 적재될 필요성은 없음.
``` 

## □ 페이지 테이블(page table)
프로세스가 메모리의 물리 주소에 불연속적으로 배치되더라도 논리주소에는 연속적으로 배치될 수 있도록 페이지 번호와 프레임 번호가 매핑되어있는 테이블. 프로세스 단위로 존재함. 
→ 프로세스들이 메모리에 분산되어 저장되어있더라도 CPU는 논리 주소를 순차적으로 실행하면 됨.
```ad-info
내부 단편화(internal fragmentation)
하나의 페이지 크기보다 작으면 남는 공간이 발생함.
내부단편화 방지와 *페이지 테이블이 너무 커지지 않도록 페이지의 크기를 조정하는 것*이 중요. 

(linux : getconf PAGESIZE)
```

▸ **PTBR(page table base register)**
CPU 내부에 각 프로세스의 페이지 테이블이 적재된 주소를 가리킴.
프로세스들의 페이지테이블 정보들은 각 프로세스의 PCB에 기록됨. (문맥교환 시 함께 변경)
 
페이지 테이블을 메모리에 두면 메모리 접근 시간이 두배로 늘어남.
1. 페이지테이블 접근
2. 프레임 접근

▸ **TLB(translation lookaside buffer)**
페이지 테이블의 캐시 메모리(페이지테이블의 참조지역성에 근거해 주로 최근에 사용된 일부를 저장)

▸ **TLB hit** : CPU가 발생한 논리 주소에 대한 페이지 번호가 TLB에 있을 경우.

▸ **TLB miss** : 페이지 번호가 TLB에 없을 경우 어쩔수없이 페이지가 적재된 프레임을 알기위해 메모리 내의 페이지 테이블에 접근.

 

## □ 페이징에서의 주소 변환
하나의 페이지 혹은 프레임은 여러주소를 포괄하여, 특정주소에 접근하려면 두가지 정보가 필요함.

1. **페이지번호(page number)** : 어떤 페이지 or 프레임에 접근하고 싶은지
2. **변위(offset)** : 접근하려는 주소가 그 페이지 or 프레임으로부터 얼마나 떨어져있는지 (pointer + N)
 

-> 논리주소의 *페이지번호, 변위*는 페이지 테이블을 통해 물리주소 *프레임번호, 변위*로 변환됨.(변위는 동일)
 

## □ 페이지 테이블 엔트리 Page Table Entry
**페이지테이블의 각각의 행**을 지칭함. 내부 정보로 대표적인 것들이 유효비트, 보호비트, 참조비트, 수정비트 등임.

  1. *유효비트(valid bit)* : 현재 해당 페이지 접근가능 여부 `메모리에있냐, 스왑에 쫓겨났냐, 보조기억장치에있냐` → 유효비트가 0(페이지가 메모리에 적재되어있지않음)일경우 page fault라는 interrupt가 발생.
     1. CPU 기존 작업내용 백업.
     2. 페이지 폴트 처리 루틴 실행.
     3. 페이지 처리 루틴은 원하는 페이지를 메모리로 가져온 뒤 유효비트를 1로 변경.
     4. 페이지 폴트를 처리했다면 이제 CPU는 해당 페이지에 접근 할 수 있음.
  2. *보호비트(protection bit)* : 페이지 보호기능을 위해 존재 (rwx:읽기,쓰기,실행) 권한 제한. 
  3. *참조비트(reference bit)* : CPU가 이 페이지에 접근한 적이 있는지 여부
  4. *수정비트(modified bit)* : 해당 페이지에 데이터를 쓴 적이 있는지 없는지 수정여부(aka. dirty bit) ⇢ 페이지가 메모리에서 사라질 때 보조기억장치에 쓰기작업을 해야할지 할필요가 없는지 판단하기 위해 존재함.

## □ 쓰기 시 복사 (copy on write)
프로세스 간 자원을 공유하지 않음. **부모 프로세스 혹은 자식 프로세스 둘 중 하나가 페이지에 쓰기 작업을 하면 그 순간 해당 페이지가 별도의 공간으로 복제**됨. 각 프로세스는 자신의 고유한 페이지가 할당된 프레임을 가리킴. (프로세스 생성시간⇣, 메모리 공간절약)

# ■ 14-3 페이지 교체와 프레임 할당
## □ 요구 페이징(demand paging)
처음부터 모든 페이지를 적재하지 않고 필요한 페이지만을 메모리에 적재하는 기법. 

1. CPU가 특정 페이지에 접근하는 명령어를 실행.
2. 해당 페이지가 현재 메모리에 있을 경우(유효비트1) CPU는 페이지가 적재된 프레임에 접근.
3. 해당 페이지가 현재 메모리에 없을 경우(유효비트0) 페이지 폴트가 발생
4. 페이지 폴트 처리 루틴은 해당 페이지를 메모리로 적재하고 유효 비트를 1로 설정
5. 다시 ⑴번 수행

```ad-info
순수 요구 페이징(pure demand paging)
아무런 페이지도 메모리에 적재하지 않은 채 무작정 실행
→ 첫 명령어 부터 페이지폴트 계속 발생 ~ 어느정도 적재되면 페이지폴트 발생빈도 하락.
```

```ad-important
요구 페이징 시스템이 안정적으로 작동하기 위한 과제
1. 페이지 교체 : 기존에 메모리에 적재된 불필요한 페이지를 선별하여 보조기억장치로 내보냄.
2. 프레임 할당 : 프로세스에 적절한 수의 프레임을 할당하여 페이지를 할당.
```

## □ 페이지 교체 알고리즘
당장 실행에 필요한 페이지를 적재하기 위해 메모리에 적재된 페이지를 보조기억장치로 내보내야함. 메모리에 적재된 많은 페이지 중 쫓아 낼 페이지를 결정하는 방법.

  1. FIFO 페이지 교체 알고리즘(first In first Out page replacement algorithm) : 가장 먼저 올라온 페이지부터 교체(제일 오래 있었으면 나가) but 프로그램 실행 초기에 넣고 실행 내내 사용할수도
※ FIFO 보완 : 2차 기회 페이지 교체 알고리즘(second chance page replacement algorithm) → 참조 비트를 활용.
2. 최적 페이지 교체 알고리즘 : CPU에 의해 참조되는 횟수를 고려하는 페이지 교체 알고리즘. 앞으로의 사용 빈도가 가장 낮은 페이지를 교체하는 알고리즘. (가장 낮은 페이지 폴트율을 보장)  
⇢ 앞으로 오랫동안 사용되지 않을 페이지를 예측하기 어려워 실제구현이 힘듦 ⸫ 다른 페이지 교체 성능 평가 척도로 사용
3. LRU 페이지 교체 알고리즘(least recently used page replacement algorithm) : 가장 오랫동안 사용되지 않은 페이지를 교체하는 알고리즘.(최근에 사용되지않은 페이지는 앞으로도 사용X 예상) 

## □ 스레싱(thrashing)
프로세스가 실제 실행되는 시간보다 페이징에 더 많은 시간을 소요하여 성능이 저해되는 문제 (프레임이 부족하면 CPU는 페이지 폴트가 자주 발생함) 
▸ *멀티프로그래밍의 정도(degree of multiprogramming)* : 메모리에서 동시 실행되는 프로세스의 수)
동시에 실행되는 프로세스 수가 어느 정도 증가하면 CPU 이용률이 높아지지만, 필요 이상으로 늘리면 각 프로세스들이 사용할 수 있는 프레임 수가 적어지기 때문에 페이지 폴트가 지나치게 빈번히 발생 ⇢ CPU이용률이 떨어져 전체적인 성능 저하.

## □ 프레임 할당 방식
스레싱이 발생하는 근본적인 원인은 각 프로세스가 필요로 하는 최소한의 프레임 수가 보장되지 않기 때문 ⸫ 최소한의 프레임 수를 파악하여 프로세스에 적절한 수의 프레임을 할당해야함.

1. 정적 할당 방식 : 프로세스의 실행과정을 고려하지 않고 단순히 프로세스의 크기와 물리메모리의 크기만 고려한 방식.
    1. 균등 할당(equal allocation) : 뿜빠이
    2. 비례 할당(proportional allocation) : 프로세스의 크기에 따라 할당

1. 동적 할당 방식 : 프로세스가 실제로 몇개의 프레임이 필요할지는 실행해 봐야 아는 경우가 많음. 프로세스의 실행을 보고 프레임 수를 결정.
	1. 작업 집합 모델(working set model) : CPU가 특정 시간동안 주로 참조한 페이지 개수만큼만 프레임을 할당하면 페이지교체는 빈번하지않음. 작업집합을 기억하여 빈번한 페이지 교체를 방지.
	   ▸ 작업집합(working set) : 실행중인 프로세스가 일정 시간 동안 참조한 페이지의 집합. ①프로세스가 참조한 페이지 ② 일정시간 간격(△time = ex.7)
2. 페이지 폴트 빈도(PFF;page fault frequency) : 페이지 폴트율에 상한선과 하한선을 정하고 이 범위 안에서만 프레임을 할당하는 방식.
	1. 페이지 폴트율이 너무 높으면 프로세스는 너무 적은 프레임을 보유. ② 페이지 폴트율이 너무 낮으면 프로세스가 너무 많은 프레임을 보유.
	 
