# ■ 03-1 소스코드와 명령어
## □ 고급언어와 저급언어
#### **저급언어**
컴퓨터가 직접 이해하고 실행할 수 있는 언어
- *기계어* : 0과 1로 이루어진 명령어 bit(cpu에는 해당 processor에 명령을 내리기 위한, 고유의 명령어가 있음)
- *어셈블리어* : 기계어를 읽기 편한 형태로 번역
  `기계어는 각 기계마다 규약된 숫자들의 규칙 조합으로, 기계어로 프로그래밍을 하기엔 매우 난해함. 가독성이 떨어지는 숫자를 대체하고자 기계어와 일대일 대응관계를 형성한 언어가 어셈블리 언어.`

#### **고급언어**
사람을 위한 언어
- *Compiled language* 
	- 컴파일러에 의해 소스코드 전체가 저급언어로 변환하여 실행되는 고급언어
	- 컴파일러 : 컴파일(코드 전체가 저급언어로 변환)을 수행해주는 도구
		- 컴파일러가 소스코드 내에서 오류를 하나라도 발견하면 해당 소스코드는 컴파일에 실패함
		- 목적코드 : 컴파일러를 통해 저급언어로 변환된 코드
- *Interpreter language*
	- 인터프리터에 의해 소스코드가 한 줄씩 실행되는 고급 언어
	- 인터프리터언어는 일반적으로 컴파일 언어보다 느림.
	- 컴파일을 통해 나온 결과물(목적코드)은 컴퓨터가 이해하고 실행할수있는 저급언어이지만 소스코드 마지막에 이를때까지 한줄한줄 저급언어로 해석해야하기 때문.
`컴파일언어와 인터프리터 언어는 확연하게 구분하기 힘듦.`

ex. python (컴파일 과정 O), java (저급언어 제작과정에서 컴파일과 interpreter를 동시 수행)

> 소스  ────┬────  목적코드  ────┬────  실행파일
  >..................... 컴파일.............................................링킹

▸ **목적코드(Object code)** : 목적코드로만 이루어진 파일(컴퓨터가 이해하는 저급언어)
▸ **Linking** : 실행시키려는 소스코드에 없는 외부기능들을 연결 짓는 작업을 수행.

```ad-example1_notinbook
소스 코드 작성: 프로그래밍 언어로 작성된 소스 코드를 생성.
1. 컴파일러 또는 인터프리터 실행: 소스 코드를 컴파일러(정적 언어) 또는 인터프리터(동적 언어)로 실행 가능한 형태로 변환.
2. 컴파일: 컴파일러를 통해 소스 코드를 기계어로 변환.
3. 링크: 여러 소스 파일을 하나의 실행 파일로 결합.
4. 로더 실행: 실행 파일을 메모리에 로드.
5. 실행: 프로그램이 메모리에서 실행.
```
  
```ad-example2_notinbook
자바의 컴파일 과정

1. 개발자가 .java 파일을 작성
2. 자바 컴파일러가 .java를 컴파일 → .class(jvm이 이해할 수 있는코드) [byte code라 명명]
3. byte code를 jvm의 class loader에게 전달
4. class loader는 동적 로딩을 통해 필요한 클래스들을 loading or linking하여 runtime data area(jvm이 사용하는 memory 영역)에 올림  
    class loader의 세부동작은 각자 알아서 찾아보길
5. execution engine은 jvm메모리에 올라온 byte code들을 명령어 단위로 하나씩 가져와서 실행 
6. interpreter : 바이트 코드 명령어를 하나씩 읽어서 해석하고 실행
7. jit compiler (just in time) : 실행시점에 기계어로 바로 컴파일 

cf. [https://yummy0102.tistory.com/510](https://yummy0102.tistory.com/510)
```

`go, c, c++ : 네이티브 바이너리 / byte code, intermediate language는 가상머신위에서 실행`


# ■ 03-2 명령어의 구조
## □ 연산 코드와 오퍼랜드
▸ **명령어** (operation code) : 명령어가 수행할 연산
operand (피연산자) : 연산에 사용할 데이터, 연산에 사용할 데이터가 저장된 위치
▸ **피연산자**: 연산에 사용될 데이터가 저장된 위치, 메모리 주소나 레지스터 이름이 담긴다 ⇨ 주소필드
▸ **연산 코드** : 기본적인 연산 코드 유형 `사실은 더 많다`
1. 데이터 전송
2. 산술/논리 연산
3. 제어 흐름 변경
4. 입출력 제어
`명령어의 종류와 생김새는 CPU 마다 다르기때문에 연산 코드의 종류와 생김새 또한 CPU마다 다르다`

## □ 주소 지정 방식
▸ 유효주소 : 연산의 대상이 되는 데이터가 저장된 위치
1. *즉시 주소 지정 방식* : 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시하는 방식. 표현할수있는 데이터의 크기가 작아지는 단점. 연산에 사용할 데이터를 메모리나 레지스터로부터 찾는 과정이 없기 때문에 다른 것보다 빠름.
2. *직접 주소 지정 방식* : 오퍼랜드 필드에 유효 주소를 직접적으로 명시하는 방식
3. *간접 주소 지정 방식* : 유효 주소의 주소를 오퍼랜드 필드에 명시. 두 번의 메모리 접근이 필요하기 때문에 앞서 설명한 애들보다 일반적으로 느림.
4. *레지스터 주소 지정 방식* : 직접 주소 지정 방식과 비슷하게 연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드에 직접 명시하는 방법. CPU 외부에 있는 메모리에 접근하는 것보다 CPU 내부에 있는 레지스터에 접근하는 것이 빠름.
5. *레지스터 간접 주소 지정 방식* : 연산에 사용할 데이터를 메모리에 저장하고 그 주소(유효 주소)를 저장한 레지스터를 오퍼랜드 필드에 명시하는 방법. 메모리에 접근하는 횟수가 한번으로 줄어든다는 장점.