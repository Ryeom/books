
이번 장의 설계는 5,000개 호텔, 100만 객실 규모의 호텔 체인을 위한 예약 시스템 구축에 대한 내용이다. 핵심 도전 과제는 **예약 과정의 ACID 속성**을 보장하는 동시에, 성수기 트래픽 급증 시 발생하는 **높은 동시성(경쟁 조건)** 문제를 해결하는 것이다. 또한, 사용자가 **특정 객실이 아닌 객실 유형을 예약**하는 호텔 비즈니스의 특성을 반영하여 시스템을 설계.

시스템은 **마이크로서비스 아키텍처**를 채택하며, **관계형 데이터베이스**를 활용하여 데이터 일관성을 최우선으로 확보. 핵심 로직은 **`room_type_inventory` 테이블**을 통해 날짜별 객실 유형 재고를 관리하고, 이중 예약 방지를 위해 **낙관적 락(Optimistic Lock) 또는 데이터베이스 제약 조건**을 적용. 향후 규모 확장을 위해 **데이터베이스 샤딩** 및 **레디스 캐시 계층** 도입을 고려.

---

## 🏗️ 단계별 설계 분석

### 1. 문제 정의 및 요구사항 (Business Context)

시스템의 목표는 예약 및 재고 관리의 정확성을 보장하는 것임.

- **시스템 규모:** 5,000개 호텔, 100만 객실 규모임.
- **트래픽 특징:** 예약 트랜잭션(TPS)은 평소 낮으나, 조회(QPS)는 높으며 성수기에 동시성이 급증함.
- **핵심 기능:** 객실 유형 예약, 10% 초과 예약 지원, 호텔/객실 정보 관리자 페이지 제공함.
- **최우선 비기능:** **데이터 일관성 (ACID)** 및 **높은 동시성 지원**임.

---

### 2. 개략적 아키텍처 및 데이터 모델

#### 2.1. 아키텍처 선택: 마이크로서비스 구조

시스템은 **공개 API 게이트웨이**를 통해 요청을 받고, **호텔, 요금, 예약, 결제, 호텔 관리 서비스** 등의 마이크로서비스로 구성됨.

- **API 게이트웨이:** 인증 및 처리율 제한(Rate Limiting)을 담당하며, 요청을 해당 서비스(예: 예약 요청은 예약 서비스)로 라우팅함.
- **서비스 간 통신:** gRPC 같은 고성능 RPC 프레임워크를 사용함.

#### 2.2. 데이터 모델 및 저장 전략: 관계형 DB 활용

**관계형 데이터베이스**를 주 저장소로 선택함. 이는 예약 시스템에서 필수적인 **ACID 속성** 보장과 쓰기 대비 압도적으로 많은 **읽기 연산** 지원에 유리함.

- **초기 문제점:** 초기 스키마가 특정 `roomID` 예약 방식에 치우쳤음.
- **개선점:** 사용자가 **특정 객실 유형(`roomTypeID`)** 을 예약하는 호텔 비즈니스 모델을 반영하여 스키마를 개선함.

---

### 3. 상세 설계 및 기술적 난제 해결

#### 3.1. 재고 관리 모델의 핵심: `room_type_inventory` 테이블

재고 관리를 위한 핵심 테이블은 `room_type_inventory`임.

- **복합 키:** `(hotel_id, room_type_id, date)`를 기본 키로 사용하여 날짜별/유형별 재고 관리가 가능함.
- **필드:** `total_inventory` (총 객실 수), `total_reserved` (예약된 객실 수)를 포함함.
- **예약 확인 로직:** 주어진 기간 내 모든 날짜에 대해 `(total_reserved + rooms_to_reserve) <= 110% * total_inventory` (초과 예약 반영) 조건을 확인하여 예약 가능 여부를 판단함.

#### 3.2. 이중 예약 방지 및 동시성 제어

**이중 예약 방지 (단일 사용자):**

- **멱등성(Idempotency) 구현:** 예약 요청 시 **`reservationID`** 를 멱등 키로 사용함. 이 키는 예약 테이블의 기본 키(PK)로 설정되어, 중복 요청 시 PK 유일성 조건 위반으로 두 번째 트랜잭션은 자동 실패됨.

**경쟁 조건 해결 (복수 사용자):**

- **낙관적 락 (Optimistic Lock):** 테이블에 `version` 필드를 추가하여 갱신 시 버전 확인을 통해 동시성 충돌을 감지함. 경쟁이 심하지 않은 상황에 적합하며, 일반적으로 호텔 예약 시스템에 적합한 방안임.
- **데이터베이스 제약 조건:** `total_inventory - total_reserved >= 0`와 같은 제약 조건을 사용하여 초과 예약 시 트랜잭션을 중단(Rollback)시킴. 구현이 단순하여 채택 가능한 방안임.

#### 3.3. 시스템 규모 확장

- **데이터베이스 샤딩:** 대부분의 질의가 `hotel_id`를 필터링 조건으로 사용함에 따라, **`hotel_id`를 샤딩 키**로 사용하여 데이터베이스 부하를 수평적으로 분산함.
- **캐시 도입 (Redis):** 읽기 QPS가 높으므로, 잔여 객실 정보 관리에 **Redis 캐시**를 도입함.
    - **잔여 객실 확인** 질의는 캐시에서 처리하여 데이터베이스 부하를 크게 줄임.
    - **데이터 일관성:** 캐시와 데이터베이스 간 불일치 문제가 발생할 수 있으나, 최종 예약 가능 여부는 **데이터베이스에서 재확인**하여 데이터 무결성을 유지함. 데이터베이스가 먼저 갱신되고 캐시는 비동기적으로 갱신됨.

#### 3.4. 마이크로서비스 간 데이터 일관성

- **하이브리드 접근:** 예약 및 잔여 객실 정보를 **동일한 관계형 데이터베이스**에 저장하여 ACID 속성을 활용하는 실용적 방식을 채택함.
- **순수 아키텍처의 대안:** 마이크로서비스별 독자 DB를 사용할 경우 데이터 일관성 유지를 위해 복잡한 **2단계 커밋(2PC)** 또는 **사가(Saga)** 패턴이 필요함.

---

## ## 주요 용어 정리

- **ACID 속성:** 트랜잭션이 안전하게 수행됨을 보장하는 4가지 특성 (원자성, 일관성, 격리성, 영속성)임.
- **멱등성 (Idempotency):** 연산을 여러 번 수행해도 한 번 수행한 것과 같은 결과를 보장하는 특성임.
- **객실 유형 예약:** 특정 객실 번호가 아닌, 스탠다드 룸이나 킹 사이즈 룸처럼 속성이 같은 객실의 종류를 예약하는 방식.
- **낙관적 락 (Optimistic Lock):** 데이터를 조회할 때 버전을 기록하고, 갱신 시 버전 불일치 발생 시 재시도를 유도하는 동시성 제어 방식임.
- **데이터베이스 샤딩:** 데이터베이스를 여러 개의 작은 조각(샤드)으로 나누어 저장하여 수평적 확장을 달성하는 기법임.
- **사가 (Saga):** 분산 트랜잭션에서 각 서비스의 국지적 트랜잭션을 순차적으로 실행하고, 실패 시 보상 트랜잭션을 통해 이전 상태로 되돌리는 데이터 일관성 패턴임.
