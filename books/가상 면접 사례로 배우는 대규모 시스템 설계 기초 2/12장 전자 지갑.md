이번 장에서의 설계 핵심 목표는 100만 TPS(초당 200만 건의 데이터베이스 연산)의 대규모 금융 거래를 처리하면서, 원자성(트랜잭션)과 영구적인 재현성(Reproducibility) 및 감사 가능성을 완벽하게 확보하는 것에 있음이다. 일반적인 분산 트랜잭션 프로토콜(2PC, TC/C)의 한계를 넘어, 이벤트 소싱(Event Sourcing) 철학을 채택하여 신뢰성과 확장성을 동시에 달성하는 것이 핵심 방안이다.

### 1. 핵심 문제: 트랜잭션, 규모, 감사 가능성

* 규모와 성능: 100만 TPS를 처리하기 위해 약 2,000개 이상의 데이터베이스 노드가 필요하며, 단일 노드의 처리량을 늘리는 것이 필수 과제임.
* 원자성 보장: 분산 환경에서 두 계좌(인출/입금)에 걸친 연산이 동시에 성공하거나 실패하도록 분산 트랜잭션을 보장해야 함.
* 감사 및 재현성 요구: 금융 시스템은 과거 특정 시점의 잔액을 정확하게 복원하고, 시스템 로직 변경 후에도 과거 기록을 재검증할 수 있는 영구적인 감사 기록(Audit Trail)을 요구함.

### 2. 핵심 해결책: 분산 이벤트 소싱 아키텍처

일반적인 분산 트랜잭션의 문제(느린 락, SPOF)를 극복하고 감사 요건을 충족하기 위해 래프트(Raft) 합의 알고리즘과 CQRS 패턴이 결합된 분산 이벤트 소싱 모델을 채택함.

| 영역 | 해결책 및 기술 채택 | 원리 및 비즈니스 효과 |
| :--- | :--- | :--- |
| 트랜잭션/원자성 | TC/C (Try-Confirm/Cancel) 또는 사가(Saga)와 같은 애플리케이션 수준 분산 트랜잭션을 사용함. | 2PC의 느린 락 문제를 피하고, 보상 트랜잭션을 통해 오류 발생 시 이전 상태를 상쇄하여 원자성을 확보함. |
| 재현성/감사 | 이벤트 소싱(Event Sourcing) 채택. 유효한 거래만 이벤트 목록(로그)에 불변하게 기록함. | 상태(잔액) 대신 상태 변화의 원인(이벤트)만 기록함. 언제든 이벤트를 처음부터 재생하여 과거 상태를 재구축(Reconstruction)할 수 있어 감사 요구사항을 완벽히 충족함. |
| 성능 최적화 | 명령/이벤트 및 상태 저장을 로컬 파일 기반 저장소(RocksDB, mmap)로 전환함. | 네트워크 I/O 오버헤드를 줄이고, HDD의 순차 쓰기 성능을 극대화하여 100만 TPS 규모의 부하를 처리함. 스냅숏을 활용하여 재현 속도를 높임. |
| 안정성/확장성 | 래프트(Raft) 합의 알고리즘을 사용하여 이벤트 목록을 복제함. | 데이터(이벤트)의 순서와 무결성을 보장하며, 과반수 노드가 작동하는 한 시스템은 안정적으로 서비스를 제공함(SPOF 문제 해결). |
| 실시간 읽기 | CQRS(명령-질의 책임 분리) 패턴과 푸시 모델을 사용함. | 쓰기 경로(명령/이벤트)와 분리된 읽기 전용 상태 기계를 구축하고, 업데이트 즉시 상태를 역방향 프락시로 푸시하여 사용자에게 실시간에 가까운 잔액 조회를 제공함. |

### 3. '정확히 한 번' 전달 보장

결제 시스템의 가장 중요한 요구사항인 이중 청구 방지(정확히 한 번 실행)는 다음 두 가지 메커니즘으로 달성함.

1.  최소 한 번 실행: 네트워크 문제 시 지수적 백오프(Exponential Back-off)를 사용하는 재시도 메커니즘을 통해 메시지 누락을 방지함.
2.  최대 한 번 실행: 클라이언트가 생성한 멱등 키(Idempotency Key)를 서버가 검사하여 중복 요청을 처리하지 않도록 함.

---

## 주요 용어 정리

* 이벤트 소싱 (Event Sourcing): 시스템의 상태(State) 대신, 상태 변화를 일으킨 모든 이벤트(Event)를 불변의 로그로 기록하는 설계 철학이다. 재현성과 감사 가능성을 극대화한다.
* 재현성 (Reproducibility): 이벤트 기록을 처음부터 다시 재생하여 과거 또는 현재의 시스템 상태를 항상 동일하게 재구축할 수 있는 시스템의 속성이다.
* 복식부기 (Double-Entry Bookkeeping): 모든 거래를 최소 두 개의 계좌에 차감/입금으로 기록하여 모든 거래의 합이 0이 되도록 보장하는 회계 원칙이다. 금융 시스템의 정확성 보장에 필수적이다.
* TC/C (Try-Confirm/Cancel): 보상 트랜잭션 기반의 분산 트랜잭션 프로토콜이다. 2PC와 달리 락을 오래 잡지 않으며, 취소(Cancel) 단계에서 보상 연산을 통해 트랜잭션의 원자성을 확보한다.
* 래프트 (Raft) 알고리즘: 분산 시스템에서 데이터 복제본 간의 합의(Consensus)를 통해 데이터의 순서와 무결성을 보장하는 알고리즘이다. 고신뢰성 솔루션 구축에 사용된다.
* CQRS (Command-Query Responsibility Segregation): 시스템에서 데이터를 변경하는 명령(Command, 쓰기)과 데이터를 조회하는 질의(Query, 읽기)의 책임을 분리하는 아키텍처 패턴이다. 읽기 성능 및 유연성을 높인다.
* 멱등성 (Idempotency): 연산을 여러 번 반복 실행해도 결과가 달라지지 않는 속성이다. 결제 시스템에서 이중 청구를 방지하는 핵심 기술이다.
* 지수적 백오프 (Exponential Back-off): 재시도 실패 시 다음 재시도까지 대기 시간을 점진적으로 늘려 서버 과부하를 방지하는 재시도 전략이다.
* RocksDB: 쓰기 성능에 최적화된 자료 구조(LSM-Tree)를 사용하는 로컬 파일 기반 키-값 저장소이다. 고성능 이벤트 소싱 시스템의 상태 저장소로 활용된다.