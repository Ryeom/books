본 설계는 DAU 500만 명 규모의 온라인 모바일 게임을 위한 실시간 순위표(Leaderboard) 시스템 구축에 대한 내용이다. 핵심 요구사항은 점수 업데이트를 실시간으로 순위표에 반영하고, 상위 10명 및 특정 사용자의 순위를 고성능으로 조회하는 것이다. 관계형 데이터베이스(RDS)는 규모 확장성과 성능 문제로 부적합하며, 레디스(Redis)의 정렬 집합(Sorted Set) 을 활용하는 것이 최적의 솔루션이다.

정렬 집합은 $O(\log N)$의 시간 복잡도로 점수 삽입 및 순위 조회를 처리하여 실시간 요구사항을 충족함. 대규모 확장을 위해서는 점수 범위 기반의 고정 파티션(Fixed Partitioning) 전략을 사용하여 샤딩을 구현했다. 또한, AWS 람다(Lambda) 와 같은 서버리스 아키텍처를 도입하여 인프라 관리 부담 없이 트래픽 증가에 따라 자동으로 규모 확장이 가능하게 한다.



## 단계별 설계 분석

### 1. 문제 정의 및 성능 요구사항 분석

순위표는 실시간으로 갱신되어야 하며, 최대 점수 획득 QPS는 2,500/초 정도.

- 비즈니스 모델: 사용자는 경기 승리 시 1점을 획득하며, 매달 새로운 순위표를 생성.
- 조회 요건: 상위 10명, 특정 사용자 순위, 그리고 특정 사용자 주변 4순위까지 조회가 요구.
- RDS의 한계: 수백만 레코드에서 순위를 매기는 작업은 전체 테이블 스캔을 요구하므로 실시간성이 불가능하며, 다량의 읽기 부하를 처리하기 어렵다.



### 2. 개략적 아키텍처 및 데이터 모델: 레디스 정렬 집합 활용

#### 2.1. 아키텍처 구성

- 책임 분리: 게임 서비스(Game Service) 가 점수의 유효성을 검증하고, 순위표 서비스(Leaderboard Service) 가 점수 갱신 및 순위 조회를 담당.
- 통신: 클라이언트가 게임 서비스를 호출하며, 게임 서비스는 순위표 서비스에 점수 갱신을 요청하는 내부 통신 구조이다.
- 서버리스 옵션: AWS API 게이트웨이와 AWS 람다를 사용하여 순위표 로직을 구현하면, 인프라 관리 없이 자동으로 규모 확장이 가능한 구조로 할수있다.
    

#### 2.2. 레디스 정렬 집합 (Sorted Set)

순위표 시스템에 가장 적합한 데이터 구조.

- 내부 구조: 해시 테이블(사용자 점수 저장)과 스킵 리스트(Skip List) (점수 정렬)를 결합한 구조이다. 스킵 리스트는 다단계 색인을 통해 빠른 검색($O(\log N)$)을 가능하게 한다.
- 핵심 연산:
    - 점수 갱신: `ZINCRBY` 명령을 사용하여 점수를 $O(\log N)$ 시간으로 업데이트.
    - 상위 N명/주변 순위 조회: `ZREVRANGE` 명령을 사용하여 특정 범위의 정렬된 사용자 목록을 조회.
    - 특정 순위 조회: `ZREVRANK` 명령을 사용하여 특정 사용자 순위를 $O(\log N)$ 시간으로 획득.
- 저장 용량: 2,500만 MAU 기준 약 650MB로, 단일 레디스 서버로 처리가 가능.



### 3. 상세 설계 및 확장성 확보

#### 3.1. 레디스 규모 확장: 샤딩 전략

5억 DAU 규모로 확장 시 샤딩이 필수적.

- 고정 파티션 (채택): 점수 범위에 따라 파티션을 분할함 (예: [1, 100], [101, 200] 등).
    - 장점: 상위 10명은 가장 높은 점수 샤드에서만 조회하면 되므로 조회 구현이 단순한 편. 특정 사용자 순위 계산도 해당 샤드보다 높은 샤드의 총 사용자 수를 합산하는 방식으로 비교적 효율적이다.
    - 단점: 점수가 고르게 분포되어야 효율적이다.
- 해시 파티션 (대안): 사용자 ID 해시를 기반으로 레디스 클러스터가 자동 분산함. 상위 N명 조회를 위해서는 모든 샤드에서 데이터를 가져와 정렬하는 분산-수집(Scatter-Gather) 방식이 필요하며, 특정 사용자 순위 계산이 복잡하다.

#### 3.2. NoSQL (DynamoDB) 기반 대안

NoSQL을 사용할 경우, 순위표를 전역 보조 색인(Global Secondary Index) 으로 구현.

- 파티션 키 설계: `game_name#{year-month}`를 파티션 키로 사용하면 핫 파티션 문제가 발생.
- 쓰기 샤딩: 이 문제 해결을 위해 파티션 키에 `partition_number` (예: `user_id % N`)를 추가하는 쓰기 샤딩 패턴을 적용함. 이는 부하를 여러 파티션에 분산하지만, 상위 순위 조회를 위해서는 분산-수집 방식이 필요하여 구현 복잡성이 증가.

#### 3.3. 추가 고려 사항

- 동점자 처리: 레디스 해시(Hash)를 사용하여 사용자 ID와 마지막 승리 타임스탬프를 저장하고, 동점 시 타임스탬프가 오래된 사용자의 순위를 높게 정하는 방식을 적용.
- 장애 복구: 레디스 장애 시, 모든 승리 기록을 저장해 둔 MySQL 데이터베이스의 이력 데이터를 읽어 순위표를 재구성하는 오프라인 복구 스크립트를 활용.

---

## 주요 용어 정리

- 정렬 집합 (Sorted Set): 레디스에서 사용하는 자료형임. 멤버와 점수(Score)로 구성되며, 점수를 기준으로 자동 정렬되어 순위표 구현에 최적이다.
    스킵 리스트 (Skip List): 정렬 집합의 내부 구조 중 하나임. 다단계 연결 리스트를 사용하여 삽입, 삭제, 검색을 $O(\log N)$ 시간 복잡도로 빠르게 수행.
- ZINCRBY / ZREVRANK: 정렬 집합의 핵심 연산임. `ZINCRBY`는 점수를 증가시키고, `ZREVRANK`는 사용자의 순위(내림차순)를 조회.
- 고정 파티션 (Fixed Partitioning): 데이터베이스 샤딩 기법 중 하나임. 점수 범위와 같은 특정 속성 값의 범위를 기준으로 데이터를 분할.
- 쓰기 샤딩 (Write Sharding): DynamoDB와 같은 NoSQL에서 특정 파티션에 쓰기 트래픽이 집중되는 핫 파티션 문제를 해결하기 위해, 파티션 키에 임의의 파티션 번호를 추가하여 쓰기 부하를 분산하는 패턴.
- 분산-수집 (Scatter-Gather): 분산 시스템에서 질의 요청을 모든 샤드에 병렬로 보내고(분산), 수신된 결과를 애플리케이션 계층에서 취합 및 재정렬하여 최종 결과를 만드는 방식.
