이번 장은 페이스북의 '주변 친구' 기능처럼 **자주 변하는 위치 정보**를 **대규모 활성 사용자(1,000만 명 동시 접속, 334K QPS)**에게 거의 **실시간**으로 효율적으로 전달하는 시스템 설계에 중점을 둠. 이 서비스는 정적인 사업장 정보 검색(1장)과 달리, **위치 정보의 푸시(Push)**가 핵심 도전이다.

#### **1. 핵심 도전: 위치 정보의 실시간 푸시 및 규모 확장**

- **근본 문제:** 초당 334,000건 이상의 위치 갱신이 발생하며, 이는 친구 네트워크를 통해 초당 1,400만 건 이상의 메시지 전파로 이어질 수 있음. 단순한 요청/응답(HTTP) 모델로는 해결 불가능한, **고부하의 양방향 통신 문제**이다.
- **해법: 웹소켓과 펍/섭을 활용한 라우팅 계층 구축:**
    - **웹소켓(WebSocket):** 클라이언트와 서버 간의 **지속성(유상태) 연결**을 유지하여 실시간 양방향 통신을 지원함.
    - **레디스 펍/섭(Pub/Sub):** 각 사용자에게 **전용 채널**을 할당하고, 친구들은 해당 채널을 **구독**하는 **초경량 메시지 버스**로 활용함. 이는 위치 정보 변경 내역을 모든 친구에게 효율적으로 전파하는 라우팅 계층의 역할을 함.

#### **2. 시스템 확장 및 데이터 전략**

- **데이터베이스 확장:**
    - **위치 정보 캐시:** 활성 사용자의 최신 위치는 **레디스 캐시**에 저장하고 **TTL**을 설정하여 비활성 사용자의 정보를 자동으로 제거함. 초당 334K의 갱신 부하를 분산하기 위해 **사용자 ID 기반의 샤딩**을 적용함.
    - **위치 이동 이력:** 막대한 쓰기 연산에 대비하여 카산드라와 같은 **수평 확장 가능한 데이터베이스**를 사용함.
- **유상태 서버 관리:** **웹소켓 서버**와 **레디스 펍/섭 클러스터**는 유상태(Stateful) 서버이다. 규모 확장이나 서버 교체 시 **'연결 종료 중(draining)'**과 같은 절차를 통해 기존 연결을 안전하게 제거하고, **서비스 탐색(Service Discovery)** 컴포넌트를 통해 클러스터 상태를 관리함.

#### **3. 최적화 및 대안**
- **병목 해결:** 레디스 펍/섭 클러스터의 병목은 메모리가 아닌 **CPU 사용량**이다.
- **기술 대안:** **얼랭(Erlang)**은 천만 활성 사용자를 **경량 프로세스**로 모델링하여 처리할 수 있는 강력한 대안으로 제시됨. 얼랭은 분산 및 병렬 애플리케이션에 최적화되어 운영 효율이 높지만, 인력 수급의 어려움이 단점이다.

---

## **주요 용어 정리**

- **유상태 서버 (Stateful Server):** 클라이언트와의 연결 정보나 세션 상태를 서버 내부에 저장하고 유지하는 서버이다. 웹소켓 서버가 대표적이며, 확장 및 축소 시 특별한 절차가 필요하다.
- **TTL (Time-To-Live):** 키-값 저장소(레디스)에서 데이터가 자동으로 만료되어 삭제되기까지 유지되는 시간이다. 비활성 사용자의 위치 정보를 캐시에서 제거하는 데 사용됨.
- **해시 링 (Hash Ring):** 안정 해시(Consistent Hashing)를 구현하는 구조로, 분산 시스템에서 데이터나 채널을 서버에 고르게 분산하고, 서버가 추가/제거될 때 데이터 재분배를 최소화하는 데 사용됨.