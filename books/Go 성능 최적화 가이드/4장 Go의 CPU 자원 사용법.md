## 4.1 최신 컴퓨터 구조의 CPU
- CPU는 명령을 실행하며, 레지스터, 캐시, 메모리 등 여러 저장 계층과 상호작용.
- 폰 노이만 구조 기반으로 설계되며, RAM과 캐시로 데이터를 저장하고 관리.

## 4.2 어셈블리어
- CPU가 명령을 실행하기 위해 고수준 코드를 어셈블리어 및 기계어로 번역.
- Go 컴파일러는 코드를 최적화하며 필요시 어셈블리어 확인으로 저수준 분석 가능.

## 4.3 Go 컴파일러 이해

Go 컴파일러는 소스 코드를 컴파일하여 실행 가능한 기계어로 변환하는 데 여러 단계를 거칩니다. 각 단계는 특정한 작업을 수행하여 최적화된 결과를 도출한다.

#### 컴파일 과정
1. **파싱 (Parsing)** : 구문 분석
    - Go 소스 코드를 구문 분석하여 토큰 (Token)으로 분할
    - 코드의 문법 구조를 분석하여 오류를 검출.
2. **추상 구문 트리 (Abstract Syntax Tree, AST)** 생성
    - 코드의 논리적 관계를 표현하며 코드 흐름의 제어 구조를 명확히 한다.
    - 이후 AST는 컴파일러의 후속 작업에서 사용되어 최적화 작업의 기반이 된다.
    - **타입 검사**
        - 변수와 함수의 **타입**이 올바른지 확인.
        - 선언되었지만 **사용되지 않은 변수**를 감지.
    - 스코프 분석 (Scope Analysis) 수행
        - 변수가 선언된 위치와 유효 범위를 설정. `문법적 scope 내`
3. 초기 최적화 및 **이스케이프 분석 (Escape Analysis)**
    - 최적화 관련 작업
        - **불필요한 코드 제거**
            - 실행되지 않을 코드나 무의미한 연산을 제거하여 바이너리 크기를 줄임
        - **함수 인라인 (Function Inlining)** 수행
            - 짧고 단순한 함수는 호출 과정을 생략하고 코드 내부로 삽입.
            - 호출 횟수가 많거나 함수 본문이 작고 단순한 경우에만 인라인 적용
    - **이스케이프 분석**:
        - 변수의 메모리 할당 방식을 결정합니다.
        - 지역 스택에 저장하거나 힙 메모리를 사용할지 판단.
    - 불변성(Immutable Property) 분석
        - 특정 변수나 데이터 구조가 변경되지 않음을 컴파일 타임에 분석 `실행중`
        - 데이터 복사를 줄이고 최적화된 코드 생성
    - 🧠 메모리 안전성 보장
        - **경계 검사(Bounds Check)**
            - 슬라이스나 배열에 접근하는 모든 코드에 대해 컴파일러가 경계 검사를 삽입.
            - 예: 루프 내 슬라이스 접근에서 범위를 초과하는지 확인.
            - 불필요한 경계 검사는 이 단계에서 제거될 수 있음.
        - **널 포인터 검사(Nil Pointer Check)**
            - 컴파일러가 모든 포인터 참조에 대해 널 여부를 확인하는 코드를 추가.
4. **정적 단일 할당(Static Single Assignment, SSA) 변환**
    - AST에 대한 초기 최적화 후 트리는 **SSA(Static Single Assignment)** 형태로 변환됨.
    - SSA는 변수의 값을 한 번만 할당하는 방식으로, 이후의 <u>추가적인 최적화</u>를 쉽게 만든다.
    - 불필요한 변수 제거와 같은 최적화 작업이 여기서 추가로 수행.
    - (필요 시) **컨트롤 플로우 그래프(Control Flow Graph, CFG) 생성**
        - SSA 변환 과정에서 코드의 실행 흐름을 그래프로 시각화하여 최적화에 활용.
5. **하드웨어와 무관한 최적화 규칙**
    - 하드웨어에 의존하지 않는 최적화 규칙을 적용.
    - 예: `y := 0 * x` 같은 문장을 `y := 0`으로 단순화.
    - 반복 계산을 제거하거나 정적으로 계산할 수 있는 값은 컴파일 시간에 미리 처리.
    - 불필요한 변수 제거 및 상수 전파(Constant Folding)
        - 상수를 컴파일 시간에 계산하여 실행 시간 연산을 줄임.
        - 예: `x := 2 + 3`을 컴파일 시점에 `x := 5`로 변환.
    - **루프 전개(Loop Unrolling)**
        - 반복 횟수가 고정된 루프를 컴파일 타임에 전개하여 실행 속도를 향상.
        - 예: `for i := 0; i < 4; i++` → 반복문을 4개의 연속된 코드로 변환.
    - **데드 코드 제거(Dead Code Elimination)**
        - 실행되지 않는 코드와 사용되지 않는 변수 또는 함수 제거.
    - 🧠 메모리 안전성 보장
        - **이스케이프 분석**
            - 변수의 메모리 할당 위치(스택 또는 힙)를 결정.
            - 예: 로컬 변수는 스택에 할당되지만, 함수 외부로 전달되거나 고루틴에서 공유되면 힙에 할당됨.
        - **스택 오버플로우 검사**
            - 고루틴의 스택 크기가 초과될 가능성을 이 단계에서 미리 검사.
            - 동적 스택 확장이 필요한 코드 삽입.
6. **기계어 생성**
    - **genssa 함수** 를 호출하여 SSA를 기반으로 기계어(ISA) 명령어로 변환.
    - Go 컴파일러는 타겟 CPU 아키텍처(x86, ARM 등)와 운영체제에 적합한 명령어를 생성.
        -  **타겟 아키텍처별 레지스터 할당 최적화**
            - 컴파일러가 타겟 CPU의 레지스터 활용을 극대화하도록 명령어를 최적화.
            - 예: x86 vs ARM 아키텍처에서 최적화 전략이 다름.
    - 🧠 메모리 안전성 보장
        - **런타임 검사 삽입**
            - 컴파일 중에 경계 검사, 널 포인터 참조 등 모든 메모리 안정성이 보장되지 않는 경우에 대해 런타임 검사 코드를 삽입.
            - 런타임에 가비지 컬렉터를 활성화하고 필요할 때 동작하도록 설정.
7. **ISA와 운영체제에 더욱 특화된 최적화**
    - 타겟 하드웨어의 특성에 따라 추가 최적화를 수행.
    - CPU의 명령어 집합(Instruction Set Architecture, ISA)에 맞는 명령을 생성.
    - SIMD(단일 명령 다중 데이터)와 같은 CPU 기능을 활용.
    - **동적 브랜치 예측 최적화**
        - CPU가 자주 호출되는 브랜치(조건문)의 실행 경로를 예측.
        - 예측이 틀릴 경우, 페널티를 최소화하는 추가 최적화 적용.
8. **목적 파일(Object File) 생성**
    - 최종 '목적파일'은 일반적으로 파일 접미사가 `.a`인 Go archive라는 `tar파일`로 압축됨.
    - 각 패키지에 대한 아카이브파일은 Go 링커나 다른 링커에서 단일 실행파일로 결합하는 데 사용 가능
    - 해당 아카이브 파일을 일반적으로 바이너리 파일 (binary file)이라고 함.
    - 디버깅 정보(DWARF) 포함
        - 디버깅을 돕기 위해 함수 이름, 변수 정보, 라인 번호 등의 메타데이터 추가.
    - Go 전용 메타데이터 포함
        - 가비지 컬렉터 및 런타임에서 사용하는 스택 정보와 Go 특유의 함수 호출 규칙 제공.
    - **외부 심볼 테이블 생성**
        - 링커가 참조할 수 있는 외부 심볼(예: 전역 함수, 변수)에 대한 정보를 포함.
    - **컴파일러 전용 힌트 추가**
        - 최적화에 필요한 컴파일러 내부 메타데이터를 목적 파일에 포함.
9. 링킹 (Linking)을 컴파일러가 호출
    - 목적 파일은 이미 생성된 상태임. 각 패키지나 모듈이 컴파일을 거쳐 독립적으로 생성된 상태.
    - Go 런타임 및 라이브러리를 포함하여 ==최종 실행 파일(Binary File) 생성.==
    - **동적 링킹 지원**
        - 라이브러리를 실행 시간에 참조할 수 있도록 동적 링킹 메커니즘 포함.
    - **라이브러리 충돌 해결**
        - 동일한 이름의 함수나 변수가 여러 라이브러리에 존재할 때, 우선순위를 지정하거나 충돌을 해결.

엄연히 링킹과 컴파일은 다른 과정임 
- **컴파일러**는 "부품을 만드는 공장"이라면,
- **링커**는 "부품을 조립하여 완성품을 만드는 공장"임.
#### 링킹 (Linking)
- 컴파일된 목적 파일은 링커에 의해 결합
- 여러 개의 목적 파일과 외부 라이브러리를 하나의 실행 가능한 바이너리로 묶음.
- 정적 링킹(모든 라이브러리를 바이너리에 포함)과 동적 링킹(시스템 라이브러리에 의존) 방식이 있음.

#### 주요 최적화
- **경계 검사 제거**: 컴파일러는 배열 접근과 같은 코드에서 불필요한 경계 검사를 자동으로 제거.
- **함수 인라인화**: 자주 호출되는 짧은 함수는 인라인화하여 호출 오버헤드를 없앰.
- **CPU 명령어 최적화**: 특정 하드웨어에 최적화된 명령어로 변환.

## 4.4 CPU와 메모리 벽 문제
- **메모리 벽 문제**: CPU는 빠르지만 메모리 접근 속도가 느려 대기시간 증가.
- 캐시, 파이프 라이닝, 비순차적 실행, 하이퍼 스레딩으로 문제 완화.
	- 참조 5장 CPU 성능 향상 기법
- 메모리 효율성을 위해 연속된 자료구조(배열 등)를 사용하는 것이 중요

> 임계 경로에서 효율적인 CPU 코드를 작성하기 위한 세 가지 원칙
> 1. 더 적은 작업을 수행하는 알고리즘을 사용
> 2. 컴파일러 및 CPU 분기 예측기가 더 최적화하기 쉽도록 복잡하지 않은 코드를 작성하는데 중점을 두기. 이상적으로는 뜨거운 코드(대부분 실행시간을 차지하는 중요한 코드)와 차가운 코드를 분리하기
> 3. 자주 반복하거나 순회할 예정이라면 메모리에 연속으로 저장된 자료구조를 사용하기

## 4.5 스케줄러
특정 프로세스를 완료하는 데 필요한, 일반적으로 제한된 자원을 할당하는 것을 의미. CPU, memory, network, disk 등의 공유자원을 사용해야하는 수천개의 프로그램을 효율적으로 비어있는 자원을 할당할수있도록 스케줄링 소프트웨어를 개발함.
### 1. 운영체제 스케줄러 feat. linux
linux scheduler의 최소 scheduling 단위는 운영체제 thread라고 한다. 개별 thread (task or 경량 process)마다 순차적으로 실행되도록 설계된 CPU명령어 묶음이 따로 있다.
!리눅스_운영체제_스케줄러의_스레드_상태.webp
- 리눅스 스케줄러(CFS)는 선점형으로 스레드를 관리하며 CPU 자원 분배.
	- 선점형 : 스케줄러가 언제든 스레드 실행을 중지 가능함. 11장 CPU 스케줄링
	- 스레드가 CPU작업 위주라면 CPU와 메모리 사용만으로 대부분의 시간을 소비하는 문제를 해결하는 방향으로 구현되어있음. → CFS (completely Fair Scheduler) 짧은 시간 간격으로 스레드를 할당. (동시에 실행되는 것처럼 보일 정도로)
		- 실행하려는 스레드가 많을 수록 각 차례에 소모되는 시간이 줄어든다. (but 문맥교환 시간 증가 및 CPU코어의 생산적 활용도 저하)
		- 과부하된 경우, 각 스레드는 자기차례에 CPU코어를 더 빨리 반납해야하고, 결국 초당 돌아오는 차례횟수가 적어짐 (스레드가 완전히 고갈or대기 상태가 되진 않았지만 실행속도가 느림)
		- CPU시간 : 수정 후 프로그램이 이전 구현보다 CPU를 더 잘 활용하는지 확실하게 확인하기가 매우 어렵다. 프로그램의 프로세스(모든 스레드)가 모든 CPU코어에서 '실행중' 상태에 있는 시간을 수집하기 위한 중요한 지표
		- 리눅스 스케줄러에는 우선순위, 사용자 설정 가능한 niceness(사용자 프로세스 간에만 적용되는 우선순위 가중치) 플래그 및 다양한 스케줄링 정책이 있음 : CFS는 너무 공정하게 시간을 배분함. 단일 스레드가 해도 온전히 CPU시간을 다 쓰지 못함.
- 과부하 상태에서는 CPU 대기시간 증가와 성능 저하 발생.
- 

### 2. Go 런타임 스케줄러
코루틴과 고루틴
- 고루틴은 가볍고 효율적인 동시성 프레임워크 제공.
- 고루틴 간 데이터 공유 시 동기화 기술(뮤텍스, 원자적 연산, 채널) 사용 필요.
- `GOMAXPROCS` 설정으로 병렬 실행 코어 수 제어 가능.

## 4.6 언제 동시성을 사용할 것인가?
- 동시성은 작업 속도 향상과 CPU 활용률 증가에 유리.
- 복잡성을 증가시킬 수 있으므로 병목현상이 해결되지 않을 때 최후의 수단으로 사용.
- TFBO 주기에 따라 동시성을 추가하기 전, 간단한 최적화 먼저 시도.

## 4.7 마치며
- CPU는 소프트웨어 실행에 필수적이며, 최신 하드웨어의 다양한 최적화 기술로 효율성 향상.
- Go의 동시성 프레임워크는 I/O 작업 및 복잡한 문제 해결에 적합한 도구 제공.
- CPU 외에도 메모리 및 I/O 자원을 고려해야 하며, 5장에서 이를 다룸.
