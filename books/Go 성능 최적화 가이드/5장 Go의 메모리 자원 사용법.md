### 핵심 요약
이 장에서는 Go의 메모리 관리와 최적화 기술을 설명합니다. 물리적 메모리의 기초, 운영체제의 메모리 관리 방식, 그리고 Go 런타임의 메모리 관리와 가비지 컬렉션(GC)을 중심으로 구성되어 있습니다.

---

## 5.1 메모리 관련성
- **RAM의 핵심 역할**: 대부분의 프로그램은 RAM을 사용하여 데이터를 캐싱하거나 작업을 처리합니다.
- **메모리의 주요 문제**:
  - **속도 차이**: RAM 접근은 CPU 속도보다 느립니다.
  - **용량 제한**: 컴퓨터의 RAM은 GB 단위로 제한적입니다.
  - **휘발성**: 전원이 꺼지면 RAM 데이터는 손실됩니다.

---

## 5.2 메모리 문제 유무 파악
- **징후**:
  - OOM(Out of Memory) 오류 발생.
  - 메모리 사용량이 과도하게 높아짐.
  - CPU 사용률이 급증하고 실행 속도가 느려짐.
- **해결 방법**: 메모리 사용량을 디버깅하고 최적화.

---

## 5.3 물리적 메모리
- **DRAM 구조**: 비트 저장을 위해 트랜지스터와 커패시터로 구성.
- **RAM 속도**:
  - 랜덤 액세스는 순차 접근보다 느립니다.
  - DDR4 SDRAM 등 최신 기술로 대역폭을 확장.
- **개발자의 역할**: 효율적인 메모리 레이아웃 설계가 중요.

---

## 5.4 운영체제 메모리 관리
- **운영체제의 역할**:
  - 각 프로세스에 전용 메모리 영역을 할당.
  - 외부 단편화 방지 및 메모리 격리 제공.
  - 효율적인 메모리 활용을 위해 가상 메모리를 사용.
- **가상 메모리와 페이지**:
  - 페이지 단위로 메모리를 관리하여 효율성 증대.
  - TLB(Translation Lookaside Buffer)를 사용해 주소 변환 가속화.
- **메모리 오버커밋**: 실제 RAM보다 많은 가상 메모리를 할당 가능.

---

## 5.5 Go 메모리 관리
- **힙과 스택**:
  - 힙: 동적 메모리 할당을 위한 주요 영역.
  - 스택: 고루틴별 지역 변수 저장에 사용.
- **할당자**:
  - 메모리 블록을 효과적으로 관리.
  - 운영체제 호출을 최소화해 성능 최적화.
- **가비지 컬렉션**:
  - 사용되지 않는 메모리를 자동으로 해제.
  - GOGC 및 GOMEMLIMIT으로 동작 제어 가능.

#### 예제: 슬라이스 할당 및 메모리 해제
```go
b := make([]byte, 600*1024*1024)  // 600MB 슬라이스 생성
b = nil                          // 슬라이스 참조 해제
runtime.GC()                     // 명시적 가비지 컬렉션 호출
```

## 5.6 마치며

Go의 메모리 관리 시스템은 대부분의 상황에서 개발 생산성을 높이지만, 대규모 데이터 처리 시 메모리 사용량과 가비지 컬렉션의 효율성을 고려해야 합니다. 프로그램 성능이 예상보다 낮다면 메모리 할당과 사용 패턴을 분석해 최적화할 필요가 있습니다.
