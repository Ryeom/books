코드에서 보안과 신뢰성을 확보하기 위한 설계 원칙과 개발 전략을 소개.

🎾 코드가 있는 페이지이므로 같이 보면서 공부하기!

## 12.1 보안과 신뢰성을 강제하는 프레임워크
### 주요 내용
- **공통 프레임워크 사용**: 보안 및 신뢰성 문제를 예방하는 검증된 구조 제공.
- **타입 기반 안전성**: SQL 주입 및 XSS 같은 취약점을 방지하는 강력한 데이터 타입 사용.
- **RPC 백엔드 프레임워크**: 인증, 승인, 로깅, 사용률 제한 등을 포함한 구조화된 워크플로우.

### 예시: RPC 백엔드 프레임워크
- **흐름 제어**: 요청과 응답의 각 단계를 인터셉터로 캡슐화해 보안과 신뢰성을 관리.
- **인터셉터**: 단계별로 로깅, 인증, 승인 로직을 분리하여 코드의 간결성과 유지 보수성을 확보.

⭐️ **중요**: 그림 12-1에서 RPC 백엔드 프레임워크의 흐름 제어를 참고.
![[Pasted image 20241222231622.webp]]

---

## 12.2 보편적인 보안 취약점과 대응
- OWASP Top 10 취약점에 대해 프레임워크 수준에서 해결책 제시.
- **SQL 주입**: Prepared Statement 사용 또는 `TrustedSqlString`과 같은 타입 도입.
- **XSS**: 신뢰할 수 없는 입력을 안전하게 처리하는 `SafeHtml` 같은 타입 사용.
#### OWASP가 공개한 가장 보편적인 취약점 위험10가지

| OWASP 취약점                  | 프레임워크 수준의 완화법                                                                                                                                                                                                                                                                            |
| -------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [SQL] 주입                   | TrustedString (다음 절 참고)                                                                                                                                                                                                                                                                  |
| 인증 오류                      | 요청을 애플리케이션에 전달하기 전에 OAuth 같은 검증된 인증 메커니즘을 사용. (12.1.2<br><br>절 예시: RPC 백엔드용 프레임워크' 참고)                                                                                                                                                                                                  |
| 민감한 데이터 노출                 | 신용카드 번호 같은 민감한 데이터는 (단순한 문자열 대신) 전용 타입을 만들어 저장하고 처리. 이 방법은 데이터 유출을 방지하기 위해 직렬화를 제한하고 적절한 암호화의 사용을 유도함.<br><br>프레임워크는 LetsEncrypt를 이용한 HTTPS 같이 전송 중에 투명한 보호 장치를 적용.<br><br>팅크(https://oreil.Ly/38Vpd)같은 암호화 API를 이용하면 키를 설정 파일이 아닌 클라우드 키 관리 시스템에서 가져오는 등 적절한 비밀번호 스토리지를 도입할 수 있다. |
| XML 외부 엔티티<br><br>(XXE)    | XXE를 비활성화한 XML 파서를 사용. XXE를 지원하는 라이브러리를 사용할 때는 이 기능 을 비활성화하기.                                                                                                                                                                                                                          |
| 접근 제어 오류                   | 이 문제는 애플리케이션에 특정한 문제일 경우가 많아 다소 까다롭다. 모든 요청 핸들러나 RPC 에 접근 제어 제한을 사용하는 프레임워크를 사용한다. 가능하다면 최종 사용자 자격 증명을 백 엔드에 보내서 접근 제어 정책을 백엔드에서 적용.                                                                                                                                                   |
| 보안 설정 오류                   | 기본적으로 안전한 설정을 제공하는 기술 스택을 사용하고 위험성이 있는 설정 옵션을 제한하거 나 허용하지 않는다. 예를 들어 에러 정보를 프로덕션 환경에서 출력하지 않는 웹 프레임워크를 사용하는 걳임. 모든 디버깅 기능은 하나의 플래그로 활성화하고 배포 및 모니터링 인프라스 트럭처를 마련해 이 플래그가 공개 사용자에게는 적용되지 않도록 함. Rais의 environment 플래그가 이 방법의 예 중 하나.                                                   |
| 크로스 사이트<br><br>스크립팅 (XSS)  | XSS에 잘 대응하는 템플릿 시스템을 사용 (12.2.2절 XSS 방지: SafeHtml' 참고)                                                                                                                                                                                                                                 |
| 안전하지 않은 역직렬화deseralization | 프로토콜 버퍼(https://orei.Ly/hlezu) 같이 신뢰하지 않은 입력을 처리하기 위해 만들어진 역직렬화 라이브러리를 사용.                                                                                                                                                                                                             |
| 취약점을 가진 컴포넌트의 사용           | 대중적이고 활발하게 관리 중인 라이브러리를 선택. 보안 이슈를 수정하지 않거나 너무 늦게 수정한 이력이 있는 컴포넌트는 사용하지 않음. 12.3절 프레임워크의 평가와 구현'을 참고.                                                                                                                                                                               |
| 불충분한 로깅과 모니터링              | 일시적인 로깅에 의존하지 말고 요청과 다른 이벤트를 저수준 라이브러리를 이용해 로깅과 모니 터링을 구축. 이전 절에서 설명했던 로깅 인터센터 예제 참고                                                                                                                                                                                                   |

## 12.3 프레임워크의 평가와 구현
- **프레임워크 선택 기준**:
  - 보안 상태 평가.
  - 유지 보수성과 업데이트 용이성.
- **구체적 사례**: `ErrorProne`을 이용한 컴파일러 수준의 보안 강제.

### 증분 롤아웃
- 레거시 코드에서 안전한 프레임워크로 점진적으로 전환.
- 안전하지 않은 API를 제한하고, 새로운 API로의 전환을 유도.

---

## 12.4 간결함이 안전과 신뢰성을 강화한다
- **다중 중첩 방지**: 중첩 코드를 줄이고 에러를 초기에 처리.
- **YAGNI 원칙 준수**: 필요 없는 코드를 미리 작성하지 않음으로써 복잡성을 줄임.
- **기술 부채 해결**:
  - 대시보드와 린터 도구 활용.
  - 코드 정리를 위한 픽스 주간 도입.
- **리팩터링**:
  - 테스트 커버리지를 기반으로 코드 간결화.
  - 리팩터링과 기능 변경은 분리.

---

## 12.5 올바른 도구와 강력한 타입 사용
### 도구 선택
- 프로젝트에 적합한 언어와 라이브러리 선택:
  - **메모리 안전성**: C++ 대신 Go와 같은 언어 활용.
  - **정적 분석 도구**: `Valgrind`, 구글의 `Sanitizer Suite`, Go의 `Race Detector`.

### 강력한 타입의 장점
- 명확한 함수 호출: 혼란 방지.
- 단위 혼선 해결: 단위 기반 타입 사용.
- 타입 기반 안전성: 런타임 에러 예방 및 문서화.

---

## 12.6 마치며
- 강력한 프레임워크와 올바른 도구 사용은 개발자의 생산성을 높이고 보안 및 신뢰성을 강화.
- 간결한 코드는 유지 보수성과 안전성을 높이며, 기술 부채 해소와 리팩터링은 장기적으로 큰 이점을 가져옴.

---

#### 용어 설명
- **SQL 주입**: 악의적인 SQL 명령이 데이터베이스에 주입되는 취약점.
- **XSS (Cross-Site Scripting)**: 악의적인 스크립트가 웹 애플리케이션에 삽입되는 취약점.
- **Prepared Statement**: SQL 쿼리에서 변수와 명령을 분리해 SQL 주입을 방지하는 방법.
- **SafeHtml**: HTML 요소에서 신뢰할 수 없는 입력값을 안전하게 처리하는 데이터 타입.
- **YAGNI (You Aren’t Gonna Need It)**: 필요하지 않은 기능을 미리 구현하지 않는 개발 원칙.
- **린터**: 코드에서 문법 오류나 비효율적인 패턴을 찾아내는 도구.
- **ErrorProne**: 자바 코드를 정적으로 분석하여 위험한 패턴을 방지하는 도구.

⭐️ **중요**: 예제 12-1, 12-3의 인터셉터 구현과 표 12-1의 OWASP 취약점과 해결책을 참고하기.

