
## 요약
10장은 [예제 4-1]의 간단한 `Sum` 구현체를 최적화하는 과정을 통해 실용적인 최적화 방법론을 탐구. 목표는 레이턴시, 메모리 사용량, 동시성 활용 등을 개선하며 다양한 패턴과 도구를 활용하는 것임. 이 과정에서 벤치마크와 프로파일링의 중요성이 강조됨.

---

## 10.1 Sum 예제
- **목표**: [예제 4-1]의 `Sum` 코드 최적화.
- 필요조건:
  - CPU 1개 사용 시 최대 레이턴시 10 * N 나노초.
  - 메모리 사용량 10KB 이하.
  - 4개 CPU 사용 시 최대 레이턴시 2.5 * N 나노초.

---

## 10.2 레이턴시 최적화
- 병목 원인 분석 및 개선:
  1. **`bytes.Split` 최적화**: `for` 루프와 개행 문자(`\n`)를 사용해 대체하여 메모리 사용량을 78% 감소.
  2. **문자열 변환 최적화**: `unsafe.Pointer`를 활용한 `zeroCopyToString`으로 변환 비용 제거.
  3. **`strconv.ParseInt` 최적화**: 커스텀 파싱 함수 구현으로 46% 성능 개선.
- 결과: 처리량 6.9 * N 나노초 달성.

---

## 10.3 메모리 사용량 최적화
- 스트리밍 알고리즘 도입 (`bufio.Scanner` 활용):
  - 메모리 사용량을 4KB로 감소했으나 레이턴시는 15.6 * N 나노초로 증가.
- 최적화:
  - 사용자 정의 버퍼링과 스트리밍 방식 도입 (`Sum6` 구현).
  - 메모리 사용량 8KB로 고정하고 처리량 6.9 * N 나노초 달성.

---

## 10.4 동시성을 이용한 레이턴시 최적화
- **단순 동시성**:
  - 각 라인별로 고루틴 생성 → 스케줄링 오버헤드로 인해 성능 저하.
- **워커 패턴**:
  - 고루틴 수 제한 및 작업 분배 → 성능 개선.
- **샤딩 기법**:
  - 작업 분배 없이 고루틴 간 파일을 균등하게 나눔 → 처리량 3.4 * N 나노초로 개선.
- **최종 구현**:
  - 파일 읽기와 작업을 동시에 진행하여 처리량 2.3 * N 나노초 달성.

---

## 10.5 추가 사항: 고정관념 벗어나기
- 간단한 캐싱 도입으로 목표 초월:
  - 동일한 입력 파일에 대해 캐싱 사용.
  - 처리량 228 나노초 및 0 바이트 메모리 사용.

---

## 10.6 마치며
- 레이턴시를 22배 개선(50.5 * N → 2.25 * N 나노초).
- 메모리 사용량을 일정하게 유지하며 개선(30.4 * N → 8KB).
- 벤치마크와 프로파일링을 활용한 체계적 최적화 프로세스 중요성 강조.
- 최적화에는 창의적 접근과 목표 중심 사고 필요.

---

## 주요 교훈
1. **병목 식별**: 프로파일링을 통해 병목을 발견하고 우선순위를 설정.
2. **단계적 개선**: 하나의 문제를 해결한 후 다른 병목을 찾는 방식으로 진행.
3. **창의적 사고**: 캐싱 같은 간단한 솔루션도 효과적일 수 있음.
4. **벤치마크 활용**: 목표에 도달했는지 반복적으로 검증.

10장은 효율성 문제를 다루는 방법론과 실용적인 사례를 통해, 최적화에서 필요한 기술과 사고방식을 제시.
