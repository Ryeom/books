
```ad-summary
이번 장에서는 메모리, $\text{I/O}$, $\text{CPU}$라는 세 가지 기본 구성 요소로 이루어진 컴퓨터 하드웨어의 기초 구조를 설명한다. 특히 명령어를 효율적으로 처리하고 실행하는 $\text{CPU}$의 핵심 장치인 $\text{ALU}$의 기능과 프로그램 저장 방식을 구현하는 데이터 경로 및 제어 방식에 초점을 맞춘다. 이는 간단한 명령어 집합을 효율적으로 설계하고, 메모리 접근 방식을 최적화하며, 최종적으로 $\text{CISC}$와 $\text{RISC}$ 같은 현대적 아키텍처의 기반 원리를 이해하는 데 필수적이다.
```
### 1. 메모리 조직 및 데이터 접근

컴퓨터 메모리는 번호가 부여된 집이 늘어선 거리와 같으며, 이 번호를 주소라고 한다. 메모리는 기본적으로 바이트 단위로 주소 지정되지만, 32비트나 64비트 컴퓨터에서는 4바이트나 8바이트 덩어리인 워드 단위로 접근하여 효율을 높인다. 이때 한 번에 두 건물(워드)에 걸쳐 데이터를 읽는 정렬이 맞지 않는 접근은 지양된다. 또한, 데이터를 메모리에 저장하는 순서(빅 엔디안과 리틀 엔디안)가 프로세서에 따라 달라지므로 시스템 간 데이터 전송 시 주의가 필요하다. $\text{I/O}$ 장치는 초기에는 메모리와 분리된 별도의 주소 공간을 사용했으나, 현대에는 메모리 주소 공간의 일부를 할당받아 동일한 버스를 사용하기도 한다.

### 2. CPU 코어 및 연산 장치 (ALU)

$\text{CPU}$는 컴퓨터의 도심부에 해당하며, 핵심 부품인 \*\*산술 논리 장치($\text{ALU}$)를 포함한다. $\text{ALU}$는 산술 연산, 불리언 대수, 시프트 연산 등을 수행하며, 연산 결과에 대한 추가 정보(음수, 0, 오버플로 등)를 조건 코드 레지스터에 저장한다. $\text{ALU}$ 내의 시프트 기능은 곱셈과 나눗셈을 빠르게 처리하는 핵심이며, 특히 배럴 시프터는 실렉터와 조합 논리를 사용하여 순차적 시프트보다 훨씬 빠르게 시프트 연산을 수행한다.

### 3. 명령어 설계와 실행 장치 (Control Unit)

$\text{CPU}$는 \*\*프로그램 카운터($\text{PC}$)가 가리키는 메모리 주소에서 명령어(instruction)를 읽어 실행한다(페치-실행 사이클). 명령어를 설계할 때, 세 개의 주소를 담는 3주소 명령어는 비효율적이므로, $\text{ALU}$ 결과를 임시 저장하는 누산기(Accumulator)를 활용하는 1주소 명령어 방식이 선호되었다. 명령어는 직접, 간접, 즉시 주소 지정 모드를 통해 메모리 접근 방식을 다양화한다. 프로그램의 논리적 흐름을 제어하기 위해 조건 코드를 검사하는 분기 명령어가 필수적이다.

### 4. 제어 방식과 아키텍처 비교

명령어의 페치와 실행을 제어하는 실행 장치(제어 장치)는 $\text{ALU}$, 레지스터, 버스의 교통을 통제한다. 이 제어 신호를 생성하는 방식에는 규칙성이 없는 회로를 사용하는 랜덤 논리 방식과, 메모리에 저장된 마이크로코드를 사용하여 제어 신호를 결정하는 방식이 있다. 현대 컴퓨터 아키텍처는 명령어의 복잡성에 따라 $\text{CISC}$와 $\text{RISC}$로 나뉜다. $\text{RISC}$는 복잡한 명령어를 단순화하고 적재-저장 구조를 사용하여 실행 속도를 최적화하는 데 중점을 둔다.

---

# 키워드 정리

### 1. 컴퓨터의 기본 구조와 메모리 조직

- CPU (Central Processing Unit) / 도심(City Center)
    - 등장 배경: 컴퓨터 하드웨어의 세 가지 핵심 구성 요소(메모리, I/O, CPU) 중 실제 계산을 처리하는 중앙의 핵심 부품이 필요했다.
    - 필요성/중요성: 컴퓨터의 모든 계산 및 데이터 흐름을 제어하는 두뇌 역할을 한다.
    - 본문 정의: 산술 논리 장치(ALU), 실행 장치 등으로 이루어진, 실제 계산을 처리하는 컴퓨터 부품이다. 비유적으로 도심에 해당한다.
    - 흐름 연결고리: 직전 키워드 없음 $\to$ 직후 - CPU가 데이터를 가져오고 저장하는 공간인 메모리의 조직화 방식으로 논의가 이어진다.
    

- 엔디안(Endian)
    - 등장 배경: 워드(Word) 같은 다중 바이트 데이터를 메모리에 저장할 때, 바이트의 순서를 어떻게 배열할지 표준이 필요했다.
    - 필요성/중요성: 데이터를 저장하는 방식(빅 엔디안, 리틀 엔디안)을 결정하며, 시스템 간 데이터를 전송할 때 데이터 순서가 뒤바뀌는 녹시 신드롬 같은 문제를 방지하기 위해 필수적이다.
    - 본문 정의: 삶은 달걀 껍질을 깰 때 둥근 쪽과 뾰족한 쪽 중 어느 쪽을 깨야 하는지에 대한 황제 칙령에서 따온 용어이며, 다중 바이트 데이터의 바이트 순서를 표현한다.
    - 흐름 연결고리: 직전 - 메모리 구조와 워드 단위 접근 $\to$ 직후 - CPU가 계산을 수행하는 핵심 장치인 산술 논리 장치(ALU)로 논의가 전환된다.
    - 잠재적 혼동 개념: 정렬이 맞지 않는 접근(Non-aligned access)과 혼동하지 않아야 한다. 엔디안은 바이트의 순서를 의미하고, 정렬은 데이터가 메모리 건물을 걸쳐 있는지 여부를 의미한다.

- I/O (Input/Output)
    - 등장 배경: 외부 세계(주변장치)와 통신하여 컴퓨터에 정보를 전달하거나 가져올 방법이 필요했다.
    * 필요성/중요성: 컴퓨터를 외부와 연결하는 통로이며, 현대에는 메모리 주소 공간의 일부를 I/O 장치에 할당하여 동일한 버스를 공유하는 것이 일반적이다.
    - 본문 정의: 입력과 출력을 줄여서 부르는 말이며, 주변장치(peripheral device)가 연결되는 경로이다.
    - 흐름 연결고리: 직전 - 메모리 버스의 조직 $\to$ 직후 - CPU의 내부 연산 장치인 ALU로 논의가 전환된다.
    


### 2. CPU 핵심 연산 장치 및 기능

- 산술 논리 장치(ALU, Arithmetic Logic Unit)
    - 등장 배경: CPU 내에서 산술 계산, 불리언 대수, 시프트 등 모든 연산을 수행하는 핵심 부품이 필요했다.
    - 필요성/중요성: CPU의 핵심 부품이며, 논리 게이트와 실렉터의 조합으로 구현된다. 연산 결과를 조건 코드 레지스터에 저장하여 이후의 제어 흐름에 영향을 준다.
    - 본문 정의: 산술 계산, 불리언 대수 및 기타 연산을 수행하는 방법을 알고 있는 CPU의 핵심 부품이다.


- 배럴 시프터(Barrel Shifter)
    - 등장 배경: 시프트 연산(곱셈/나눗셈에 유용함)을 순차적인 시프트 레지스터처럼 한 클록에 1비트씩이 아니라, 여러 비트를 한 번에 처리하여 속도를 높여야 했다.
    - 필요성/중요성: 조합 논리만으로 구현되어 여러 비트의 시프트 연산을 한 클록에 완료할 수 있어 CPU 성능 향상의 핵심적인 부분이다. 부동소수점 연산 구현에도 필수적이다.
    - 본문 정의: 실렉터와 조합 논리를 사용하여 순차적인 방식보다 빠르게 여러 비트의 시프트를 수행할 수 있는 회로이다.


### 3. 명령어 구조와 CPU 제어 방식

- 프로그램 저장 방식 컴퓨터 (Stored-program computer) / 명령어 (Instruction)
    - 등장 배경: CPU에게 할 일을 알려주는 명령 목록을 메모리에 저장해두고 실행할 필요가 있었다. (앨런 튜링과 존 폰 노이만의 연구에서 비롯된 아이디어이다.)
    - 필요성/중요성: 프로그램이 데이터와 마찬가지로 메모리에 저장되는 구조이며, 현대 컴퓨터의 근본적인 작동 방식이다.
    - 본문 정의: 명령어 목록을 메모리에 저장해두고 CPU가 메모리에서 명령어를 가져와 실행하는 컴퓨터를 말한다. 명령어는 컴퓨터에게 어떤 일을 할지 알려주는 비트 패턴이다.
    - 흐름 연결고리: 직전 - 실행 장치의 필요성 $\to$ 직후 - 명령어를 메모리에서 가져올 위치를 추적하는 핵심 레지스터인 프로그램 카운터가 등장한다.
    

- 누산기 (Accumulator) / 1주소 명령어
    - 등장 배경: 3주소 명령어는 명령어 비트가 주소 지정에 모두 소모되어 메모리 크기에 한계가 있었고, 메모리 접근 핀 문제로 인해 비효율적이었다.
    - 필요성/중요성: ALU의 계산 결과를 임시 저장하는 레지스터로, 한 메모리 위치와 누산기 값을 연산하고 결과를 누산기에 넣는 1주소 명령어 방식을 가능하게 하여 주소 비트를 더 많이 활용할 수 있게 한다.
    - 본문 정의: ALU가 계산한 결과를 저장하는 레지스터로, ALU가 계산한 결과를 저장한다. 1주소 명령어를 사용하는 컴퓨터 설계에서 핵심이다.
    - 흐름 연결고리: 직전 - 명령어의 효율적 설계 $\to$ 직후 - 메모리 주소 지정 시 사용할 수 있는 다양한 접근 방식인 주소 지정 모드로 논의가 확장된다.
    

- 주소 지정 모드 (Addressing Mode)
    - 등장 배경: 명령어에 포함된 주소 비트의 크기가 제한적이므로, 제한된 비트로 더 많은 메모리 영역에 접근하거나 상수를 지정할 방법이 필요했다.
    - 필요성/중요성: 직접, 간접, 즉시 주소 지정 방식을 통해 명령어의 유연성과 메모리 접근 범위를 확장한다. $\text{C}$ 언어의 포인터는 간접 주소 지정을 추상화한 것이다.
    - 본문 정의: 명령어에 들어 있는 값(주소)을 해석하는 방식이다. 직접(주소가 메모리 위치), 간접(주소가 피연산자 주소를 담고 있는 메모리 위치), 즉시(주소가 곧 값) 모드가 있다.
    - 흐름 연결고리: 직전 - 1주소 명령어 $\to$ 직후 - 프로그램의 실행 흐름을 제어하기 위한 분기 명령어로 이어진다.
    

- 마이크로코드 (Microcode) / 랜덤 논리 (Random Logic)
    - 등장 배경: 명령어의 페치(fetch)와 실행(execute) 단계에서 발생하는 복잡한 제어 신호(교통)를 효과적으로 결정하고 관리할 방법이 필요했다.
    - 필요성/중요성: CPU의 제어 장치(실행 장치)를 구현하는 두 가지 주요 방식이다. 마이크로코드는 메모리를 사용하여 제어 신호를 결정하며, 랜덤 논리는 규칙성이 없는 게이트 조합 회로를 사용하여 제어한다.
    - 본문 정의: 명령어 실행에 필요한 제어 신호를 결정하기 위해 메모리 내에 저장된 작은 컴퓨터(프로그램)이다.
    - 흐름 연결고리: 직전 - 명령어를 통한 실행 제어 $\to$ 직후 - 명령어의 복잡성과 제어 장치의 복잡성을 연관 지어 CISC/RISC 아키텍처 비교로 이어진다.

### 4. 아키텍처 비교와 최신 동향

- RISC (Reduced Instruction Set Computer) / CISC (Complicated Instruction Set Computer)
    - 등장 배경: 복잡한 명령어(CISC) 중 상당수가 거의 쓰이지 않아 제어 회로만 복잡해지는 비효율 문제를 해결하기 위해 등장했다.
    - 필요성/중요성: RISC는 자주 쓰이는 단순한 명령어만을 사용하여 제어 회로를 단순화하고 각 명령어의 실행 속도를 높여 전체 성능을 최적화한다. $\text{RISC}$는 적재-저장 구조를 특징으로 한다.
    - 본문 정의: $\text{CISC}$는 복잡한 명령어 집합을 사용하는 기존 설계 방식이며, $\text{RISC}$는 프로그램 실행 시간을 대부분 차지하는 단순한 명령어만을 포함하는 방식으로 설계된 컴퓨터이다.
    - 흐름 연결고리: 직전 - CPU 제어 방식의 복잡성 $\to$ 직후 - $\text{CPU}$ 외 특화된 병렬 처리 장치인 $\text{GPU}$로 논의가 마무리된다.

- GPU (Graphics Processing Unit)
    - 등장 배경: 그래픽 처리처럼 대량의 데이터를 병렬로 빠르게 처리해야 하는 특화된 작업에 $\text{CPU}$ 대신 사용할 장치가 필요했다.
    - 필요성/중요성: 간단한 처리 장치가 많이 들어있고 메모리 버스 폭이 넓어 그래픽 처리를 병렬화하는 데 매우 효율적이다. 최근에는 인공지능 등 일반 응용 분야에도 사용된다.
    - 본문 정의: 그래픽 처리를 위한 장치이며, 간단한 처리 장치를 아주 많이 포함하고 $\text{CPU}$보다 메모리 버스의 폭이 넓어 병렬화에 유리하다.
    - 흐름 연결고리: 직전 - $\text{RISC}$와 $\text{CISC}$ $\to$ 직후 - (마무리)