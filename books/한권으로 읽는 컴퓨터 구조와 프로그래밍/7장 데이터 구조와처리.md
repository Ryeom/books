

이 장은 하드웨어의 메모리 특성을 고려하여 소프트웨어 수준에서 데이터를 효율적으로 조직하고 처리하는 방법인 데이터 구조를 설명한다. 기본적인 데이터 타입과 배열에서 시작하여, 메모리를 유연하게 사용하는 연결 리스트와 동적 할당, 그리고 대용량 데이터를 효율적으로 관리하기 위한 트리, 파일 시스템, 해싱 기술로 발전하는 과정을 다룬다. 핵심은 데이터의 특성에 맞춰 메모리 공간과 처리 속도 사이의 트레이드 오프를 조절하여 최적의 성능을 끌어내는 것이다.


## 1. 기본 데이터의 조직화: 배열과 구조체

프로그래밍 언어는 정수, 부동소수점 같은 기본 데이터 타입을 제공하며, 메모리 주소를 저장하는 포인터를 통해 간접 주소 지정을 구현한다. 배열은 동일한 타입의 데이터를 메모리에 연속적으로 배치하여 인덱스로 빠르게 접근하는 구조이다. (비유: 아파트) 아파트의 호수처럼 인덱스를 이용해 데이터 위치를 즉시 계산한다. 다차원 배열의 경우 행 우선 또는 열 우선 방식으로 메모리에 일렬로 나열되며, 참조 지역성을 고려해 순회하는 것이 성능에 유리하다. 비트맵은 불리언(참/거짓) 정보를 비트 단위로 압축하여 저장하는 효율적인 배열이다. 구조체는 서로 다른 타입의 데이터를 하나로 묶어 처리하며, 이때 메모리 정렬을 맞추기 위해 패딩이 추가될 수 있다.

## 2. 동적 데이터 관리: 리스트와 메모리 할당

데이터의 개수가 가변적일 때는 크기가 고정된 배열 대신 연결 리스트를 사용한다. 리스트는 데이터와 다음 데이터의 주소(포인터)를 함께 저장하여 연결하는 방식이다. 이러한 동적 데이터는 힙(Heap)이라는 메모리 영역에서 할당(malloc)받고 사용 후 해제(free)해야 한다. 이 과정에서 메모리 누수나 잘못된 포인터 사용을 막기 위해, 시스템이 자동으로 사용하지 않는 메모리를 회수하는 가비지 컬렉션 기능이 사용되기도 한다. 이중 연결 리스트는 앞뒤 노드를 모두 가리켜 탐색과 삭제를 더 효율적으로 만든다.

## 3. 계층적 구조와 대용량 저장소 관리

데이터 검색 속도를 높이기 위해 선형 구조(리스트) 대신 계층적 구조인 트리를 사용한다. 2진 트리는 스무고개처럼 매 단계마다 탐색 범위를 절반으로 줄여 검색 효율을 높인다. 디스크와 같은 대용량 저장장치에서는 블록 단위 접근 효율을 높이기 위해 가지가 많은 B 트리를 사용하여 데이터베이스를 구축한다. 파일 시스템은 아이노드(인덱스 노드)를 사용하여 파일 정보를 저장하고, 간접 블록을 통해 대용량 파일을 관리하며, 디렉터리를 통해 계층적 구조를 형성한다.


### 4. 고속 접근과 처리 효율화

데이터를 정렬해 두면 검색 속도가 빨라지지만, 데이터 변경 시 비용이 발생한다. 해싱은 데이터를 정렬하는 대신, 키 값을 해시 함수에 넣어 데이터가 저장된 위치(버킷)를 즉시 계산해내는 방식이다. (비유: 정리된 서류함 vs 이름만 대면 위치를 알려주는 사서) 해시 충돌이 발생하면 체인 등을 이용해 해결한다. 데이터 이동 시에는 루프 언롤링이나 더프의 장치 같은 기법으로 CPU의 분기 예측 실패를 줄여 복사 속도를 높이거나, 분산/수집(벡터 I/O)을 이용해 데이터 복사 자체를 줄이는 방식으로 성능을 최적화한다.


---

# 키워드 정리

### 1. 데이터의 기본 구성과 메모리 배치

- 포인터 (Pointer)
    - 등장 배경: 데이터 자체가 아니라 데이터가 저장된 메모리 위치(주소)를 다루는 효율적인 방법이 필요했다.
    - 필요성/중요성: 메모리 주소를 값으로 가지며, 간접 주소 지정을 통해 복잡한 데이터 구조(리스트, 트리 등)를 연결하는 핵심 도구이다.
    - 본문 정의: 컴퓨터 아키텍처에 따라 결정되는 크기의 부호 없는 정수이며, 메모리 주소로 해석된다.
    - 흐름 연결고리: 직전 키워드 없음 $\to$ 직후 - 포인터를 활용하거나 연속된 메모리를 사용하여 데이터를 묶는 배열과 구조체로 이어진다.
    - 잠재적 혼동 개념: 참조(Reference)와 혼동하지 않아야 한다. 참조는 포인터를 추상화하여 안전하게 만든 것으로 실제 주소 연산은 제한된다.

- 배열 (Array) / 행 우선 (Row-major)
    -  등장 배경:  같은 종류의 데이터를 효율적으로 모아 관리하고, 번호(인덱스)를 통해 빠르게 접근할 필요가 있었다.
    -  필요성/중요성:  메모리 상에 데이터를 연속적으로 배치하여 인덱스 계산만으로 위치를 찾을 수 있다. 다차원 배열을 메모리에 일렬로 나열할 때  행 우선  방식을 주로 사용하며, 이는  참조 지역성 에 영향을 준다.
    -  본문 정의:  같은 타입의 원소들이 연속적으로 배치된 데이터 구조이며, 기저 주소와 오프셋을 이용해 접근한다.
    -  흐름 연결고리:   직전  - 포인터 $\to$  직후  - 배열의 공간 낭비를 줄이기 위해 비트 단위로 제어하는  비트맵 으로 최적화된다.