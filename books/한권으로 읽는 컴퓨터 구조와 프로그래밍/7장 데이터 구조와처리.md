

이 장은 하드웨어의 메모리 특성을 고려하여 소프트웨어 수준에서 데이터를 효율적으로 조직하고 처리하는 방법인 데이터 구조를 설명한다. 기본적인 데이터 타입과 배열에서 시작하여, 메모리를 유연하게 사용하는 연결 리스트와 동적 할당, 그리고 대용량 데이터를 효율적으로 관리하기 위한 트리, 파일 시스템, 해싱 기술로 발전하는 과정을 다룬다. 핵심은 데이터의 특성에 맞춰 메모리 공간과 처리 속도 사이의 트레이드 오프를 조절하여 최적의 성능을 끌어내는 것이다.


## 1. 기본 데이터의 조직화: 배열과 구조체

프로그래밍 언어는 정수, 부동소수점 같은 기본 데이터 타입을 제공하며, 메모리 주소를 저장하는 포인터를 통해 간접 주소 지정을 구현한다. 배열은 동일한 타입의 데이터를 메모리에 연속적으로 배치하여 인덱스로 빠르게 접근하는 구조이다. (비유: 아파트) 아파트의 호수처럼 인덱스를 이용해 데이터 위치를 즉시 계산한다. 다차원 배열의 경우 행 우선 또는 열 우선 방식으로 메모리에 일렬로 나열되며, 참조 지역성을 고려해 순회하는 것이 성능에 유리하다. 비트맵은 불리언(참/거짓) 정보를 비트 단위로 압축하여 저장하는 효율적인 배열이다. 구조체는 서로 다른 타입의 데이터를 하나로 묶어 처리하며, 이때 메모리 정렬을 맞추기 위해 패딩이 추가될 수 있다.

## 2. 동적 데이터 관리: 리스트와 메모리 할당

데이터의 개수가 가변적일 때는 크기가 고정된 배열 대신 연결 리스트를 사용한다. 리스트는 데이터와 다음 데이터의 주소(포인터)를 함께 저장하여 연결하는 방식이다. 이러한 동적 데이터는 힙(Heap)이라는 메모리 영역에서 할당(malloc)받고 사용 후 해제(free)해야 한다. 이 과정에서 메모리 누수나 잘못된 포인터 사용을 막기 위해, 시스템이 자동으로 사용하지 않는 메모리를 회수하는 가비지 컬렉션 기능이 사용되기도 한다. 이중 연결 리스트는 앞뒤 노드를 모두 가리켜 탐색과 삭제를 더 효율적으로 만든다.

## 3. 계층적 구조와 대용량 저장소 관리

데이터 검색 속도를 높이기 위해 선형 구조(리스트) 대신 계층적 구조인 트리를 사용한다. 2진 트리는 스무고개처럼 매 단계마다 탐색 범위를 절반으로 줄여 검색 효율을 높인다. 디스크와 같은 대용량 저장장치에서는 블록 단위 접근 효율을 높이기 위해 가지가 많은 B 트리를 사용하여 데이터베이스를 구축한다. 파일 시스템은 아이노드(인덱스 노드)를 사용하여 파일 정보를 저장하고, 간접 블록을 통해 대용량 파일을 관리하며, 디렉터리를 통해 계층적 구조를 형성한다.


### 4. 고속 접근과 처리 효율화

데이터를 정렬해 두면 검색 속도가 빨라지지만, 데이터 변경 시 비용이 발생한다. 해싱은 데이터를 정렬하는 대신, 키 값을 해시 함수에 넣어 데이터가 저장된 위치(버킷)를 즉시 계산해내는 방식이다. (비유: 정리된 서류함 vs 이름만 대면 위치를 알려주는 사서) 해시 충돌이 발생하면 체인 등을 이용해 해결한다. 데이터 이동 시에는 루프 언롤링이나 더프의 장치 같은 기법으로 CPU의 분기 예측 실패를 줄여 복사 속도를 높이거나, 분산/수집(벡터 I/O)을 이용해 데이터 복사 자체를 줄이는 방식으로 성능을 최적화한다.


---

# 키워드 정리

### 1. 데이터의 기본 구성과 메모리 배치

- 포인터 (Pointer)
    - 등장 배경: 데이터 자체가 아니라 데이터가 저장된 메모리 위치(주소)를 다루는 효율적인 방법이 필요했다.
    - 필요성/중요성: 메모리 주소를 값으로 가지며, 간접 주소 지정을 통해 복잡한 데이터 구조(리스트, 트리 등)를 연결하는 핵심 도구이다.
    - 본문 정의: 컴퓨터 아키텍처에 따라 결정되는 크기의 부호 없는 정수이며, 메모리 주소로 해석된다.
    - 흐름 연결고리: 직전 키워드 없음 $\to$ 직후 - 포인터를 활용하거나 연속된 메모리를 사용하여 데이터를 묶는 배열과 구조체로 이어진다.
    - 잠재적 혼동 개념: 참조(Reference)와 혼동하지 않아야 한다. 참조는 포인터를 추상화하여 안전하게 만든 것으로 실제 주소 연산은 제한된다.

- 배열 (Array) / 행 우선 (Row-major)
    -  등장 배경:  같은 종류의 데이터를 효율적으로 모아 관리하고, 번호(인덱스)를 통해 빠르게 접근할 필요가 있었다.
    -  필요성/중요성:  메모리 상에 데이터를 연속적으로 배치하여 인덱스 계산만으로 위치를 찾을 수 있다. 다차원 배열을 메모리에 일렬로 나열할 때  행 우선  방식을 주로 사용하며, 이는  참조 지역성 에 영향을 준다.
    -  본문 정의:  같은 타입의 원소들이 연속적으로 배치된 데이터 구조이며, 기저 주소와 오프셋을 이용해 접근한다.
    -  흐름 연결고리:   직전  - 포인터 $\to$  직후  - 배열의 공간 낭비를 줄이기 위해 비트 단위로 제어하는  비트맵 으로 최적화된다.

- 비트맵 (Bitmap) / 마스크 (Mask)
    -  등장 배경:  불리언(참/거짓)처럼 단순한 정보를 저장할 때 바이트나 워드 단위를 쓰는 것은 메모리 낭비이므로, 비트 단위로 관리할 방법이 필요했다.
    -  필요성/중요성:  1비트로 하나의 상태를 표현하여 메모리 효율을 극대화한다. 특정 비트를 조작하기 위해  비트 마스크 와 논리 연산(AND, OR)을 사용한다.
    -  본문 정의:  비트의 배열로, 각 비트가 하나의 상태를 나타내는 데이터 구조이다.
    -  흐름 연결고리:   직전  - 배열 $\to$  직후  - 단일 데이터가 아닌 서로 다른 타입의 데이터를 묶는  구조체 로 논의가 확장된다.


- 구조체 (Structure) / 패딩 (Padding)
    -  등장 배경:  날짜(년, 월, 일)처럼 서로 연관된 다양한 타입의 데이터를 하나의 단위로 묶어서 관리하고 싶었다.
    -  필요성/중요성:  복합적인 데이터를 논리적으로 그룹화하여 코드의 가독성과 관리 편의성을 높인다. 하드웨어의 메모리 접근 효율을 위해 멤버 사이에  패딩 을 넣어 메모리 정렬을 맞춘다.
    -  본문 정의:  사용자가 정의한 복합 데이터 타입으로, 여러 멤버를 포함하는 '스위트'와 같은 구조이다.
    -  흐름 연결고리:   직전  - 비트맵 $\to$  직후  - 정적인 데이터 구조의 한계를 넘어, 데이터 크기가 변할 때 사용하는  연결 리스트 로 넘어간다.
    -  잠재적 혼동 개념:   공용체(Union) 와 혼동하지 않아야 한다. 구조체는 멤버들이 각자 메모리를 차지하지만, 공용체는 모든 멤버가 같은 메모리 공간을 공유한다.


### 2. 동적 데이터 구조와 메모리 관리

- 연결 리스트 (Linked List)
    -  등장 배경:  배열은 크기가 고정되어 있어 데이터 추가/삭제 시 데이터를 전부 복사해 옮겨야 하는 비효율이 발생했다.
    -  필요성/중요성:  데이터와 다음 데이터의 주소(포인터)를 묶어 관리함으로써, 메모리 위치에 상관없이 데이터를 연결하고 중간 삽입/삭제를 효율적으로 수행한다.
    -  본문 정의:  노드에 다음 원소에 대한 포인터가 들어 있는 리스트 구조이다.  이중 연결 리스트 는 이전 원소 포인터도 포함한다.
    -  흐름 연결고리:   직전  - 구조체 $\to$  직후  - 이런 동적 노드를 생성하기 위해 필요한 메모리 공간인  힙 과  할당기(malloc) 로 이어진다.

- 힙 (Heap) / 동적 메모리 할당 (malloc)
    -  등장 배경:  프로그램 실행 중에 크기가 결정되는 동적 데이터를 저장할 공간이 필요했다.
    -  필요성/중요성:  정적 데이터 영역이나 스택과 달리, 프로그래머가 필요할 때 메모리를 요청( malloc )하고 반납( free )할 수 있는 자유로운 메모리 영역이다.
    -  본문 정의:  프로그램이 실행 중에 동적으로 할당받아 사용하는 메모리 영역이다.
    -  흐름 연결고리:   직전  - 연결 리스트 $\to$  직후  - 수동 메모리 관리의 오류를 방지하기 위한  가비지 컬렉션 으로 논의가 이어진다.
    -  잠재적 혼동 개념:   스택(Stack) 과 혼동하지 않아야 한다. 스택은 함수 호출과 지역 변수를 위해 자동으로 관리되지만, 힙은 개발자가 관리해야 한다.


- 가비지 컬렉션 (Garbage Collection)
    -  등장 배경:  프로그래머가 직접 메모리를 해제하는 과정에서 메모리 누수나 이미 해제된 메모리 접근 같은 치명적인 오류가 자주 발생했다.
    -  필요성/중요성:  런타임 환경이 사용되지 않는 메모리를 자동으로 추적하여 해제함으로써 메모리 관리의 안전성을 높인다. 자바 등의 언어에서 채택했다.
    -  본문 정의:  프로그램이 동적으로 할당했던 메모리 영역 중에서 더 이상 사용할 수 없게 된 영역을 자동으로 해제하는 기법이다.
    -  흐름 연결고리:   직전  - 동적 메모리 할당 $\to$  직후  - (다음 섹션) 데이터를 선형이 아닌 계층적으로 관리하여 검색 효율을 높이는  트리 구조 로 전환된다.