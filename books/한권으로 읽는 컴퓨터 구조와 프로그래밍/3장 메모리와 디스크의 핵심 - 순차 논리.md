```ad-summary
컴퓨터는 조합 논리만으로는 상태를 기억할 수 없기 때문에 발진자를 사용해 시간을 만들고 순차 논리를 도입하여 과거 상태를 기억한다. 이 순차 논리의 기본 요소인 래치와 플립플롭을 기반으로 RAM, ROM, 디스크 같은 다양한 메모리 장치와 오류 감지/정정 기술이 발전하는 과정을 이해하는 것이 이 장의 핵심이다. 이 모든 저장 기술은 시간을 기준으로 상태를 기억하며, 메모리 용량의 증가에 따라 효율적인 조직화와 오류 방지 기술이 필수적으로 요구된다.
```

### 1. 시간의 생성과 순차 논리의 도입

순차 논리는 입력의 현재 상태뿐만 아니라 과거 상태까지 고려하여 출력을 결정하는 논리이다. 컴퓨터는 되먹임(feedback) 회로와 크리스털을 활용한 발진자(oscillator)를 통해 주기적인 전기 신호인 클록을 만들어 시간을 인식한다. 이 클록은 회로의 동작 속도(페이스)를 결정하며, 부품의 편차를 감안해 속도를 조절하는 비닝(binning) 과정이 필수적이다.

### 2. 상태 기억의 기본 요소 (래치와 플립플롭)

정보를 1비트 기억하는 가장 기본적인 회로인 래치(Latch)는 되먹임 구조를 통해 과거 상태를 유지한다. 래치의 문제를 해결하고 클록에 맞춰 정확한 시점에 데이터를 기억하게 만든 것이 플립플롭(Flip-flop)이다. 플립플롭은 논리 수준이 특정 값에 머무는 동안이 아니라, 에지(edge)(클록 신호가 0에서 1 또는 1에서 0으로 전이되는 순간)에 데이터를 잡아낸다. 플립플롭을 기반으로 수를 세는 카운터와 여러 비트를 한 번에 저장하는 레지스터 같은 고수준의 회로가 만들어진다.

### 3. 메모리 장치의 조직화와 진화

- RAM (임의 접근 메모리): 메모리의 위치를 지정하는 주소(address)는 디코더와 실렉터를 통해 처리된다. 대용량 메모리 칩은 주소 라인의 수를 줄이기 위해 주소를 행과 열로 나누는 멀티플렉싱 방식을 사용한다. SRAM은 빠르지만 비싸고, DRAM은 집적도가 높지만 주기적으로 상태를 갱신(refresh)해야 하는 휘발성 메모리이다.
- ROM (읽기 전용 메모리): $\text{ROM}$은 한 번 기록 후 반복 읽기가 가능한 메모리이며, 홀러리스 카드, 코어 로프 메모리 같은 초기 형태에서 PROM, EPROM, EEPROM과 플래시 메모리로 진화했다.
- 대용량 저장장치: 디스크 드라이브는 자화된 원판에 데이터를 저장하며, 탐색 시간과 회전 지연 시간으로 인해 RAM보다 느리다. 데이터를 블록 단위로 읽고 쓴다. 플래시 메모리를 디스크 형태 패키지에 넣은 SSD가 등장하여 기계적 문제를 해결하고 고속화했으며, 조정(wear leveling) 기술로 수명을 관리한다.

### 4. 데이터 신뢰도와 오류 관리

메모리 장치에서 발생할 수 있는 데이터 오류를 감지하고 복구하는 기술이 필수적이다. 패리티(Parity)는 1비트 오류만 감지할 수 있으며, 오류가 짝수 번 발생하면 감지하지 못하는 한계가 있다. 더 복잡한 오류까지 감지하고 정정할 수 있는 해밍 코드를 사용하는 ECC 메모리가 데이터 센터 등에 사용된다. 프로그램처럼 정적인 데이터 블록의 무결성을 검증하기 위해 체크섬이나 순환 중복 검사($\text{CRC}$) 같은 방식이 사용된다.

---


# 키워드 정리

### 1. 시간 생성과 순차 논리의 기초

- 순차 논리(Sequential logic)
    - **등장 배경:** 조합 논리만으로는 과거 상태를 기억하거나, 1부터 100까지 더하는 것과 같은 시간 흐름을 이용하는 계산을 수행할 수 없었기 때문에 도입되었다.
    - **필요성/중요성:** 입력의 현재 상태와 **과거 상태**를 함께 고려하여 출력을 결정하며, 컴퓨터가 상태를 기억하고 시간을 다루는 모든 메모리 및 제어 회로의 기초이다.
    - **본문 정의:** 입력의 현재 상태와 과거 상태를 함께 고려하는 논리이며, 시간의 순서(sequence)라는 말에서 비롯된 용어이다.
    - **흐름 연결고리:** **직전 키워드 없음** $\to$ **직후** - 순차 논리에 필수적인 시간의 기준을 만들기 위해 **발진자(클록)**가 도입된다.
    - **잠재적 혼동 개념:** **조합 논리**와 혼동하지 않아야 한다. 조합 논리는 오직 현재 입력에 의해서만 출력이 결정된다.

- 발진자(Oscillator) / 클록(Clock)
    - **등장 배경:** 순차 논리를 작동시키고 회로의 동작 속도를 결정하기 위한 **주기적인 시간 기준 신호**가 필요했다.
    - **필요성/중요성:** 컴퓨터의 모든 회로 동작의 페이스(pace)를 결정하는 박자표 역할을 한다. **크리스털(석영)**을 활용하여 정확하고 안정적인 주파수를 생성한다.
    - **본문 정의:** 주기적인 전기 신호를 만들어내는 장치이며, 컴퓨터의 동작 시간을 셀 수 있게 해주는 신호가 **클록**이다.
    - **흐름 연결고리:** **직전** - 순차 논리의 시간 기반 확립 $\to$ **직후** - 클록의 신호를 이용하여 정보를 1비트 기억하는 최소 단위인 **래치**가 만들어진다.

### 2. 상태 기억의 최소 요소와 타이밍

- 래치(Latch)
    - **등장 배경:** 클록 신호를 이용해 정보를 1비트 기억하고 과거 상태를 유지하는 회로가 필요했다.
    - **필요성/중요성:** OR 게이트의 출력을 입력에 묶는 **되먹임(feedback)** 구조를 통해 자신의 과거 상태를 기억하는 가장 기본적인 1비트 메모리 회로이다.
    - **본문 정의:** 되먹임을 사용하여 정보를 기억하며, set과 reset 신호를 통해 값을 설정하거나 재설정할 수 있는 회로이다.
    - **흐름 연결고리:** **직전** - 클록 $\to$ **직후** - 래치가 클록이 '열려있는' 동안 D 입력의 변화를 그대로 출력에 반영하는 문제를 해결하기 위해 **플립플롭**이 도입된다.

- 플립플롭(Flip-flop)
    - **등장 배경:** 래치가 클록이 활성화된 기간 내내 입력 변화를 반영하는 문제를 해결하여, **정확한 순간**에만 데이터를 기억해야 했다.
    - **필요성/중요성:** 논리 수준이 특정 값에 머무는 동안이 아니라, **에지(edge)**(전이되는 순간)에만 데이터를 잡아내는 **에지 촉발형 래치**이다. 이는 데이터 안정성 확보에 필수적이다.
    - **본문 정의:** 논리 수준이 한 수준에서 다른 수준으로 전이되는 중간인 **에지**에서 데이터 변화가 촉발되는 래치이다.
    - **흐름 연결고리:** **직전** - 래치의 문제점 $\to$ **직후** - 플립플롭의 정확한 동작을 보장하기 위해 **설정 시간 및 유지 시간**과 같은 타이밍 요소가 중요해진다.

- 레지스터(Register)
    - **등장 배경:** 플립플롭을 응용하여 여러 비트를 동시에 기억하고 처리하는 회로가 필요했다.
    - **필요성/중요성:** 클록을 공유하는 여러 D 플립플롭을 한 패키지에 넣은 것으로, 가산기의 결과를 저장하거나 중앙 처리 장치에서 데이터를 임시 저장하는 데 사용되는 핵심 요소이다.
    - **본문 정의:** 클록을 공유하는 여러 D 플립플롭을 한 패키지에 넣은 회로이다.
    - **흐름 연결고리:** **직전** - 플립플롭 $\to$ **직후** - 레지스터를 많이 쌓아두었을 때 원하는 레지스터를 찾아가는 **메모리 조직 및 주소 지정** 문제로 논의가 확장된다

### 3. 메모리 장치의 조직과 RAM의 진화

- RAM (임의 접근 메모리)
    - **등장 배경:** CPU가 데이터를 처리할 때 원하는 위치에 어디든 원하는 순서로 데이터를 쓰고 읽을 수 있는 휘발성 메모리가 필요했다.
    - **필요성/중요성:** 컴퓨터의 주 메모리 역할을 한다. 접근 위치를 지정하기 위해 **주소(address)**를 사용하며, 디코더와 실렉터를 통해 해당 주소에 접근한다.
    - **본문 정의:** 메모리 위치 중 원하는 곳은 어디든 원하는 순서로 쓰거나 읽을 수 있는 메모리이다.
    - **흐름 연결고리:** **직전** - 레지스터를 확장하여 메모리 조직 $\to$ **직후** - $\text{RAM}$의 두 가지 주요 형태인 **$\text{SRAM}$과 $\text{DRAM}$**의 장단점 비교로 이어진다.

- SRAM 및 DRAM
    - **등장 배경:** 메모리 집적도, 속도, 비용에 따라 다양한 $\text{RAM}$ 형태가 필요했다.
    - **필요성/중요성:** **$\text{SRAM}$**은 빠르지만 비싸고 비트당 트랜지스터가 6개 들어가며, **$\text{DRAM}$**은 집적도가 높지만 주기적으로 상태를 **갱신(refresh)**해야 하는 단점이 있다.
    - **본문 정의:** **$\text{SRAM}$**은 정적 $\text{RAM}$으로 트랜지스터 6개를 사용하며, **$\text{DRAM}$**은 동적 $\text{RAM}$으로 커패시터에 전자를 담아 주기적으로 갱신이 필요하다.
    - **흐름 연결고리:** **직전** - $\text{RAM}$의 정의 $\to$ **직후** - $\text{RAM}$의 휘발성 문제를 해결하고 프로그램 저장에 쓰이는 **읽기 전용 메모리($\text{ROM}$)**로 논의가 전환된다.
    - **잠재적 혼동 개념:** **휘발성 메모리**이다. 전원이 끊어지면 데이터가 사라진다.

### 4. 비휘발성 저장 장치와 오류 관리

- **읽기 전용 메모리(ROM)**
    - **등장 배경:** 전자레인지처럼 프로그램을 내장하여 전원이 꺼져도 데이터가 유지되는 비휘발성 메모리가 필요했다.
    - **필요성/중요성:** 한 번 쓰고 나면 여러 번 읽을 수 있는 메모리이다. $\text{PROM, EPROM, EEPROM}$ 등 다양한 형태로 발전했으며, 최종적으로 **플래시 메모리**로 진화하는 기초가 되었다.
    - **본문 정의:** 한 번 쓰고 나면 여러 번 읽을 수 있는 메모리이며, **홀러리스 카드**나 **코어 로프 메모리** 같은 초기 형태가 있었다.
    - **흐름 연결고리:** **직전** - $\text{RAM}$의 휘발성 문제 $\to$ **직후** - 비휘발성이면서 대용량 저장에 특화된 **디스크 드라이브**로 이어진다.
    - **잠재적 혼동 개념:** **$\text{RAM}$**과 혼동하지 않아야 한다. $\text{RAM}$은 휘발성이며 임의 접근이 가능하고 쓰기 속도가 빠르다.

- **디스크 드라이브 (Disk Drive)**
    - **등장 배경:** $\text{RAM}$이나 $\text{ROM}$보다 훨씬 더 많은 데이터를 저장하기 위한 대용량 비휘발성 저장장치가 필요했다.
    - **필요성/중요성:** 엄청난 양의 데이터를 자화된 **원판(platter)**에 저장하며, **대량 저장장치(mass storage)**로 쓰인다.
    - **본문 정의:** 자화된 원판에 비트를 저장하는 장치이며, 데이터를 **블록(block)** 단위로 주소 지정해 읽고 쓴다.
    - **흐름 연결고리:** **직전** - $\text{ROM}$ $\to$ **직후** - 디스크 드라이브의 기계적 한계(느린 속도)를 극복하기 위해 **플래시 메모리/SSD**가 등장한다.
    - **잠재적 혼동 개념:** **플로피 디스크**와 혼동하지 않아야 한다. 디스크 드라이브는 딱딱한 원판을 사용해 '하드 드라이브'로 불렸다.

- **플래시 메모리 / SSD**
    - **등장 배경:** 디스크 드라이브의 기계적 문제(탐색 시간, 회전 지연)로 인한 느린 속도를 개선하고, 소형 기기에 적합한 비휘발성 메모리가 필요했다.
    - **필요성/중요성:** $\text{EEPROM}$의 한 유형으로, 기계적인 움직임 없이 데이터를 저장하는 **고체 상태 드라이브($\text{SSD}$)**의 핵심이다. 읽기 속도는 빠르나, 쓰기 시 블록 단위로 지워야 한다.
    - **본문 정의:** $\text{EEPROM}$ 유형의 매체이며, 버킷에 전자를 담아 비휘발성을 유지하고 **블록 단위**로 지우고 쓸 수 있다. $\text{SSD}$는 이 플래시 메모리를 디스크 모양으로 패키징한 것이다.
    - **흐름 연결고리:** **직전** - 디스크 드라이브의 기계적 한계 $\to$ **직후** - 메모리/저장장치의 데이터 신뢰성을 위한 **오류 감지 및 정정** 기술로 논의가 전환된다.
   

### 5. 데이터 신뢰도와 오류 관리

- **패리티(Parity)**
    - **등장 배경:** 우주 방사선 등으로 메모리 비트가 잘못되었을 때, 원본 복사본 없이 오류 발생 여부만이라도 빠르게 감지할 필요가 생겼다.
    - **필요성/중요성:** 데이터에서 1로 설정된 비트의 개수를 세고, 그 개수가 짝수인지 홀수인지 나타내는 1비트를 추가하여 **단 1비트의 오류**를 감지하는 간단하고 값싼 방법이다.
    - **본문 정의:** 데이터에서 1로 설정된 비트의 개수를 세어, 그 개수가 짝수인지 홀수인지 나타내는 1비트를 데이터에 덧붙이는 것이다.
    - **흐름 연결고리:** **직전** - 플래시 메모리 $\to$ **직후** - 1비트 오류 감지를 넘어 더 복잡한 오류를 처리하기 위한 **해밍 코드 및 체크섬** 기술이 도입된다.
    

- **해밍 코드 / 체크섬 (Checksum)**
    - **등장 배경:** 패리티가 오류가 짝수 번 발생하면 감지하지 못하거나, 오류를 정정할 수 없는 한계를 극복하기 위해 필요했다.
    - **필요성/중요성:** **해밍 코드**는 오류가 일어난 부분을 바로 **수정**할 수 있으며, **체크섬**은 데이터의 고유성을 검증하는 검증 숫자를 계산하여 데이터의 무결성을 확인한다.
    - **본문 정의:** **체크섬**은 데이터의 각 지점을 더하고 넘어가는 값은 무시하여 검증 숫자를 계산하는 단순한 방법이며, **해밍 코드**는 오류를 감지하고 정정까지 가능한 더 복잡한 코드이다.
    - **흐름 연결고리:** **직전** - 패리티의 한계 $\to$ **직후** - (마무리)
    - **잠재적 혼동 개념:** **체크섬**은 **순환 중복 검사($\text{CRC}$)**나 **해시 코드**보다 단순하지만, 위양성(false positive) 문제가 발생할 수 있다.