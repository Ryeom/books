```ad-summary
이 장은 $\text{CPU}$의 성능과 프로그래밍 편의성을 극대화하기 위해 도입된 컴퓨터 아키텍처의 복잡한 구조 개선 사항을 설명한다. 핵심은 함수 호출과 재귀를 지원하는 스택의 원리, 멀티태스킹 환경에서 프로그램 간 격리를 담당하는 메모리 관리 장치($\text{MMU}$) 및 가상 메모리 시스템, 그리고 성능을 최적화하는 메모리 계층 구조에 대한 이해이다.

```


### 1. 아키텍처의 기본 구조와 성능 진화

컴퓨터 구조는 명령어와 데이터 메모리를 분리하여 속도를 높인 하버드 구조와, 명령어와 데이터가 메모리를 공유하는 폰 노이만 구조로 나뉜다. 반도체 회로가 작아지면서 전력 장벽 문제에 부딪히자, $\text{CPU}$는 프로세서 코어의 정의를 바꾸고 멀티코어 시스템으로 진화한다. 또한, 메모리와 $\text{I/O}$를 $\text{CPU}$와 같은 칩에 패키징하는 방식에 따라 마이크로프로세서와 마이크로컴퓨터($\text{SoC}$) 등으로 구분된다.

### 2. 프로그램 제어 및 스택 구조

프로그래밍 효율을 위해 코드를 재사용하는 함수(서브루틴) 개념이 필수적이며, 함수 호출 후 원래 자리로 돌아오는 반환 주소를 기억하는 메커니즘이 필요하다. 특히 재귀 함수처럼 여러 호출 위치를 순서대로 저장하고 복원하기 위해 스택(stack) 구조가 도입된다. 스택은 $\text{LIFO}$ 방식으로 작동하며, 함수 호출 시 반환 주소와 지역 변수를 포함하는 스택 프레임을 저장한다. 스택의 범위를 제한하는 한계 레지스터는 스택 오버플로를 방지하는 역할을 한다.


### 3. 운영체제와 프로그램 격리 (MMU)

프로그램이 동시에 실행되는 멀티태스킹 환경을 관리하기 위해 운영체제($\text{OS}$)가 등장한다. $\text{OS}$는 인터럽트 시스템을 통해 외부 이벤트(타이머, $\text{I/O}$)에 즉각적으로 반응하여 실행 중인 프로그램을 중단(중단)시키고 인터럽트 핸들러를 실행한다. 프로그램 간의 메모리 간섭 및 $\text{OS}$ 보호를 위해 \*\*메모리 관리 장치($\text{MMU}$)가 도입된다. $\text{MMU}$는 가상 주소를 물리 주소로 변환하여 각 프로그램에게 자신만의 메모리 공간이 있는 것처럼 보이게 한다(가상 메모리). 물리적 메모리가 부족하면 $\text{OS}$는 사용 빈도가 낮은 페이지를 디스크로 옮기는 스와핑을 통해 가용 메모리를 확장한다.


### 4. 성능 최적화와 계층 구조

$\text{CPU}$와 주 메모리 사이의 속도 격차를 해소하기 위해 메모리 계층 구조가 도입된다. 이 구조는 빠르고 비싸지만 용량이 작은 레지스터와 \*\*캐시($\text{L1/L2/L3}$)를 $\text{CPU}$ 가까이에 배치하고, 느리고 저렴한 주 메모리 및 대량 저장장치로 이어진다. $\text{CPU}$는 캐시에서 데이터를 찾지 못하는 캐시 실패를 줄이기 위해 분기 예측 및 순서를 벗어나는 실행 기술을 사용한다. 또한, $\text{CPU}$의 부하를 줄이기 위해 데이터 복사를 전담하는 코프로세서나 $\text{DMA}$ 같은 기술이 사용된다.