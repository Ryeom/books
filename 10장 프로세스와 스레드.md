# ■ 10-1 **프로세스 개요**

▸ 프로세스 (process) : 실행중인 프로그램! 
`✚ 보조기억장치에 저장된 프로그램을 메모리에 적재하고 실행하는 순간 프로그램은 프로세스가 됨(프로세스 생성)`

## □ **프로세스 직접 확인하기**

컴퓨터가 부팅되는 순간부터 수많은 프로세스들이 실행됨.

1. 윈도우 : 작업관리자에서 확인
2. 유닉스 : *ps* 명령어로 확인

▸ 프로세스의 종류 : 
1. **foreground process** : 사용자가 보는앞에서 실행됨
2. **background process** : 사용자가 보지 못하는 뒤편에서 실행됨
`✚ 윈도우에서는 service라고 부르고, 유닉스 계열에서는 daemon이라고 부름.`

## □ **프로세스 제어 블록**

CPU자원은 한정되어 있기때문에 모든 프로세스가 CPU를 동시에 사용할 수 없음. 차례가 돌아가며 한정된 시간만큼만 CPU를 이용함. 자신의 차례가되면 정해진 시간 만큼 CPU를 이용하고 시간이 끝났음을 알리는 인터럽트(`타이머 인터럽트 : 클럭신호를 발생시키는 장치에 의해 주기적으로 발생하는 하드웨어 인터럽트 aka 타임아웃 인터럽트`)가 발생하면 자신의 차례를 양보하고 다음 차례가 올때까지 대기함.

▸ 프로세스 제어 블록 (PCB ; process control block) : 프로세스를 식별하기위해 필요한 정보를 저장하는 자료 구조 *상품에 달린 tag*

커널 영역에 생성됨. 운영체제는 빠르게 수행되는 프로세스의 실행순서를 관리하고 프로세스에 CPU를 비롯한 자원을 배분할때 PCB를 사용함.

▸ PCB에 저장되는 정보
1. **프로세스ID (PID;process ID)** : 프로세스를 식별하기위해 부여하는 고유번호
2. **레지스터 값** : 이전까지 사용했던 레지스터의 중간값 복원 (⸪ 이전까지 실행했던 작업들을 그대로 이어 실행하기위해) ⇢ 프로세스가 실행하며 사용했던 프로그램 카운터를 비롯한 레지스터 값.
3. **프로세스 상태** : 입출력장치 사용대기, CPU 사용대기, CPU 이용중 등의 상태 정보
4. **CPU 스케줄링 정보** : 프로세스가 언제, 어떤 순서로 CPU를 할당받을지에 대한 정보
5. **메모리 관리 정보** : 프로세스마다 메모리에 저장된 위치가 다름. 프로세스가 어느 프로세스에 저장되어있는지, 페이지테이블 정보 등에 대한 정보가 있어야 함.
6. **사용한 파일과 입출력장치 목록** : 어떤 입출력 장치가 이 프로세스에 할당 되었는지, 어떤 파일들을 열었는지에 대한 정보가 PCB에 기록됨.
7. 등등

`PCB는 프로세스 생성시에 만들어지고 실행이 끝나면 폐기됨.`

## □ **문맥 교환**

▸ <span style="background:#fff88f">문맥 (context)</span> : 하나의 프로세스 수행을 재개하기 위해 기억해야 할 정보.

PCB에 기록되는 정보들을 문맥이라고 봐도 무방. 실행문맥을 잘 기억해 두면 언제든 해당 프로세스의 실행을 재개할 수 있기 때문에 프로세스가  CPU를 사용할 수 있는 시간이 다 되거나 예기치 못한 상황이 발생하여 인터럽트가 발생하면 운영체제는 해당프로세스의 PCB에 문맥을 백업함. 
▸ **문맥 교환 (context switching)** : 기존 프로세스의 문맥을 PCB에 백업하고 새로운 프로세스를 실행하기위해 PCB로부터 복구하여 새로운 프로세스를 실행하는 것.

문맥교환은 여러프로세스가 끊임없이 빠르게 번갈아 가며 실행되는 원리. 문맥교환이 자주 일어나면 프로세스는 그만큼 빨리 번갈아 가며 수행되기때문에 사용자의 눈에는 프로세스들이 동시에 실행되는 것처럼 보임.

`문맥교환을 너무 자주하면 오버헤드가 발생할 수 있기때문에 문맥교환이 자주일어난다고 해서 반드시 좋은것은 아님.`

  

## □ 프로세스의 메모리 영역

프로세스가 생성되면 커널영역에 PCB가 생성.

▸ 사용자 영역에 배치되는 프로세스 영역
1. **코드영역 (code segment aka. text segment)** : 기계어로 된 명령어가 저장됨 (쓰기금지, readonly)
2. **데이터영역 (data segment)** : 잠깐 썼다가 없앨 데이터가 아닌 프로그램이 실행되는 동안 유지할 데이터가 저장 (ex. 전역변수 global variable)
3. **힙 영역 (heap segment)** : 프로그래머가 직접 할당할수있는 저장공간. 프로그래밍 과정에서 힙영역에 메모리 공간을 할당했다면 언젠가는 해당 공간을 반환해야함. (반환 : 메모리 공간을 사용하지 않겠다.) 메모리 공간을 반환하지 않으면 할당된 공간은 메모리 내에 계속 남아 메모리 낭비를 초래함 (메모리 누수:memory leak) 
4. **스택 영역 (stack segment)** : 데이터를 일시적으로 저장하는 공간. 데이터 영역과는 달리 잠깐 쓰다가 말 값들이 저장되는 공간 (ex. parameters, local variable) 

*heap, stack segment는 실시간으로 그 크기가 변할 수 있기 때문에 동적 할당 영역이라고 부른다. 

힙영역은 메모리의 낮은 주소에서 높은 주소로 할당되고 스택영역은 높은주소에서 낮은 주소로 할당됨.

  
  

# ■ 10-2 **프로세스 상태와 계층구조**

## □ 프로세스 상태

▸ 프로세스가 가질 수 있는 대표적인 상태
1. **생성 (new)** : PCB를 할당받은 상태, 실행준비를 완료한 프로세스는 곧바로 실행되지않고 준비상태가 되어 CPU의 할당을 기다림
2. **준비 (ready)** : 아직 자신의 차례가 아니기에 대기중. 차례가 되어야 실행상태가 된다.
   *dispatch : 준비 상태인 프로세스가 실행상태로 전환되는 것*
3. **실행 (running)** : CPU를 할당 받아 실행중인 상태를 의미 
4. **대기 (blocked)** : 입출력 장치의 작업을 기다리는 상태.
5. **종료 (terminated)** :프로세스가 종료된 상태. PCB와 프로세스가 사용된 메모리를 정리함.


⇢ 프로세스 상태 다이어그램 (process state diagram)

  

## □ 프로세스 계층 구조

프로세스는 실행 도중 시스템 호출을 통해 다른 프로세스를 생성 할 수 있음.

새 프로세스를 생성한 프로세스를 부모 프로세스(parent process), 생성된 프로세스를 자식 프로세스(child process)라고 함.

▸ PID (parent PID) : 부모 프로세스의 PPID

대다수의 운영체제는 프로세스가 프로세스를 낳는 계층적인 구조로써 프로세스들을 관리함.

컴퓨터가 부팅될 때 실행되는 최초의 프로세스가 자식프로세스들을 생성하고 생성된 자식 프로세서들이 새로운 프로세스를 낳는 형식으로 여러 프로세스가 동시에 실행됨.


`✚ 최초의 프로세스 : 최초의 프로세스 PID는 항상 1번이며 모든 프로세스의 최상단에 있는 부모프로세스.`

unix : init, linux : systemd, macOS : launchd

> pstree (프로세스 계층구조를 보여주는 명령어)

  

## □ 프로세스 생성 기법

부모 프로세스를 통해 생성된 자식 프로세스 들은 복제와 옷 갈아입기를 통해서 실행된다.

자신(부모프로세스)의 복사본을 자식프로세스로 생성(fork)해 내고 만들어진 복사본(자식)은 exec를 통해 자신의 메모리 공간을 다른 프로그램으로 교체함.

`fork와 exec는 system call임.`

*복사본이기때문에 부모프로세스의 자원(메모리내의 내용, 열린파일 목록 등) 자식프로세스에 상속됨. 이때, 복사본이라 하더라도 PID나 저장된 메모리 위치는 다름)*

`부모가 자식프로세스를 실행하며 프로세스 계층구조를 이루는 과정은 fork와 exec가 반복되는 과정임.`

  
  

# ■ 10-3 스레드 

▸ <span style="background:#fff88f">스레드 (thread)</span> : 프로세스를 구성하는 실행의 흐름 단위. 실행에 필요한 최소한의 정보 (프로그램카운터, 레지스터, 스택)만을 유지한 채 프로세스 자원을 공유하며 실행된다는 점.

## □ 프로세스와 스레드

▸ 단일 스레드 프로세스 : 실행 흐름의 단위가 하나

▸ 멀티 스레드 프로세스 : 프로세스를 구성하는 여러 명령어들을 동시에 실행할 수 있음.

*최근의 많은 운영체제는 CPU에 처리 할 작업을 전달 할 때 프로세스가 아닌 **스레드 단위**로 전달함.

*리눅스의 경우 프로세스와 스레드간의 명확한 구분을 짓지 않음. **context of execution이라는 점에서 동등하다고 간주**함. 두언어를 사용하지 않고 task라고 통칭. 

cf. 리눅스 창시자 “리누스 토르발스"의 철학 :  https://lkml.iu.edu/hypermail/linux/kernel/9608/0191 .html

  

## □ 멀티프로세스와 멀티스레드

▸ **멀티 프로세스 (multiprocess)** : 여러 프로세스를 동시에 실행하는 것.

▸ **멀티 스레드 (multithread)** : 여러 스레드로 프로세스를 동시에 실행하는 것.

▸ 프로세스끼리는 기본적으로 자원을 공유하지않지만 스레드끼리는 같은 프로세스 내의 자원을 공유함.

`A : “hello! os!” 를 출력하는 프로그램`
 1. A를 3번 fork하여 실행 ⇢ “hello! os!”이 3번 출력 
 2. A내에 “hello! os!”를 출력하는 스레드를 3개 만들어 실행 ⇢ “hello! os!”이 3번 출력

`1과 2는 같은 결과이지만 메모리에 적재되는 방식에는 차이가 있다.`

  1. 코드영역, 데이터 영역, 힙영역 등을 비롯한 모든 자원이 복제되어 메모리에 중복 적재됨. ⇢ PID, 저장된 메모리 주소를 제외하면 모든 것이 동일한 프로세스 두개가 통째로 메모리에 적재됨. 같은 프로그램을 실행하기위해 메모리에 동일한 내용들이 중복해서 존재하게됨. 서로 다른 프로세스들은 기본적으로 자원을 공유하지않기때문에 서로가 남남처럼 독립적으로 실행됨.

  2. 스레드는 프로세스의 자원을 공유하기때문에 서로 협력과 통신에 유리. 자원을 공유한다는 특성은 단점이 될 수도 있는데 멀티 프로세스 환경에서는 하나의 프로세스에 문제가 생겨도 다른 프로세스에는 지장이 적거나 없지만 멀티스레드 환경에서는 하나의 스레드에 문제가 생기면 프로세스 전체에 문제가 생길 수 있음. 모든 스레드는 프로세스의 자원을 공유하고 하나의 스레드에 문제가 생기면 다른 스레드도 영향을 같이 받음.

`fork를 한 직후 같은 프로세스를 통째로 메모리에 중복없이 저장하지 않으면서 동시에 프로세스끼리 자원을 공유하지않는방법도 존재함 ⇢ 쓰기 시 복사(copy on write)`

  

▸ 프로세스 간 통신 (IPC; inter-process communication) : 기본적으로 프로세스간에는 자원을 주고받지않지만 프로세스 끼리도 자원과 데이터를 공유할 수 있음. 

1. 파일을 통한 프로세스 간 통신
2. 공유메모리 (shared memory) : 서로 공유하는 메모리영역을 둠
3. socket
4. PIPE

*프로세스 간 데이터를 교환하는 것은 모든 자원을 처음부터 공유하는 스레드에비하면 까다로울 뿐 불가능은 아니다~

